(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



If[$VersionNumber < 10., 
   CellPrint[{Cell[TextData[{StyleBox["You need at least Mathematica 10.0 to run OptEx.Quitting the Mathematica kernel....", FontFamily -> "Constantia"]}], "Text", 
       FontSize -> 15, TextAlignment -> Left, ShowCellBracket -> False]}]; Abort[]]; 
If[ !ValueQ[OptEx`$OptExDirectory], OptEx`$OptExDirectory = DirectoryName[$InputFileName]]; 
If[ !ValueQ[OptEx`$GuideDirectory], OptEx`$GuideDirectory = FileNameJoin[{OptEx`$OptExDirectory, "Documentation", "English", "Guides"}]]; 
If[FileNames["*", {OptEx`$OptExDirectory}] === {}, 
   CellPrint[{Cell[TextData[{StyleBox["Could not find a OptEx installation. Quitting the Mathematica kernel....", FontFamily -> "Constantia"]}], "Text", FontSize -> 15, 
       TextAlignment -> Left, ShowCellBracket -> False]}]; Clear[OptEx`$OptExDirectory]; Abort[]; ]; 
OptEx`$OptExVersion = "1.0";
OptEx`Private`$MachineLogZero=-0.99*$MaxMachineNumber;
$MachineLogZero = -0.99*$MaxMachineNumber; 


(* ::Input::Initialization:: *)
CellPrint[{Cell[DisplayForm[StringJoin["    OptEx-", OptEx`$OptExVersion]], "Text", CellFrame -> False, FontColor -> Black, Editable -> False, 
    FontFamily -> "Lucida Handwriting", TextAlignment -> Left, FontSize -> 20, ShowCellBracket -> False], Cell[DisplayForm["Sunando K. Patra\n IIT Kanpur, India"], "Text", 
    CellFrame -> False, FontColor -> Black, Editable -> False, FontFamily -> "Segoe Script", TextAlignment -> Left, FontSize -> 14, ShowCellBracket -> False], 
   Cell[TextData[{StyleBox["If you are using ", FontFamily -> "Constantia"], StyleBox["OptEx", FontSize -> 16, FontFamily -> "Lucida Handwriting"], 
      StyleBox[" for the first time, try running ' ", FontFamily -> "Constantia"], StyleBox["OptExHelp[ ];", FontFamily -> "Consolas", FontSize -> 15, FontWeight -> Bold], 
      StyleBox[" '.", FontFamily -> "Constantia"]}], "Text", FontSize -> 15, TextAlignment -> Left, ShowCellBracket -> False]}]


BeginPackage["OptEx`",{"ErrorBarPlots`","Developer`"}];


(* ::Input::Initialization:: *)
OptExHelp;
covMatGen;
errorFormat;
matrixSymmetrize;
hessianMat;
errorMat;
errorInfo;
sigmaLevel;
deltaChiSqVal;
ConfLevel;


(* ::Input::Initialization:: *)
dataForm;
correlationForm;
objectType;
assoObject;
assoObjectQ;


(* ::Input::Initialization:: *)
dataObject;
dataObjectQ;
freeParamForm;
nuisanceForm;
paramObject;
paramObjectQ;
paramList;


(* ::Input::Initialization:: *)
addData;
removeData;
addParam;
removeParam;


(* ::Input::Initialization:: *)
correlationCreate;
listObject;
populateData;
fitObject;
fitObjectQ;
vecForm;
obAr::usage="Define"
vecFormP;
covMatForm;
chiSqForm;
chiSqFormP;
chiSqFormFit;
chiSqFormFitP;
rangeForm;
constraintForm;
chiSqMinimForm;
pSimulData;
pValueMC;
dofSimple;
pValue;


(* ::Input::Initialization:: *)
Emerald;TangerineTango;Iris;
colorPalette;showPalette;
colorsx;
triPlotPartUni;
triPlotPartMVG;


(* ::Input::Initialization:: *)
priorBayes;
chiSqBayes;
modelLogLike;
priorLogDensity;
PlotPrior2D;
triPlotPrior;
chiSqTab;


(* ::Input::Initialization:: *)
PlotFisher2D;
triPlotFisher;


(* ::Input::Initialization:: *)
TimeLeft;
TimeProgress;
MapMonitored;
MCMCResult;
MCMCResultQ;


(* ::Input::Initialization:: *)
apply;
MCMCFast;
BayesFastFit;


(* ::Input::Initialization:: *)
MCMCMath;
BayesMathFit;


(* ::Input::Initialization:: *)
MCMCMath2;
BayesMathFit2;


(* ::Input::Initialization:: *)
resetBurn;
saveRun;
loadRun;
Posterior1D;
savePlots1D;
Posterior2D;
Posterior2DCombo;

distPlot2D;

conpdf;
triPlotPosterior;
savePlots2D;


(* ::Input::Initialization:: *)
batchFitObjectQ;
batchFitParam;
modelSelect;
FitFromBatch;


(* ::Input::Initialization:: *)
chiSqMinObject;
chiSqMinObjectQ;
NHessian;
errorMatForm;
HesseResult1D;
sigDigit;
errorDisplay1;
errorDisplay2;
errorDisplay;
errorDisplayList;
scanObject;
CLScanProb1D;
CLScanFC1D;
CLProbObject;
CLObjectQ;


(* ::Input::Initialization:: *)
pMC1D;
(*pMC1D2;*)


(* ::Input::Initialization:: *)
endPoints;
mainHDR;
HDReg;
CLResult1D;
CLPlot1D;


(* ::Input::Initialization:: *)
CLScanProb2D;
CLPlot2D;


(* ::Input::Initialization:: *)
errorProp;
pulls;
MSEfit;
partFit;
MSEpart;
kFoldXValidation;
cookDistance;
cookCutoff;


(* ::Input::Initialization:: *)
resultForm;
asymmErrSimple;
resultTable;
texTable;


Begin["`Private`"]


OptExHelp::usage="OptExHelp[] opens the OptEx guide, with all help files listed."
OptExHelp[]:=
NotebookOpen[FileNameJoin[{$UserBaseDirectory,"Applications","OptEx","Documentation","English","Tutorials","OptExOverview.nb"}]];


covMatGen::usage = "covMatGen[errlst_List,cormat] \n creates a covariance Matrix from list of uncertainties 'errlst' and correlation matrix 'cormat'."
covMatGen::nosymm = "The correlation matrix `1` is not symmetric."
covMatGen[errlst_, cormat_] := 
If[SymmetricMatrixQ[Evaluate[Normal[cormat]]],
 Table[errlst[[i]]*errlst[[j]]*cormat[[i,j]], {i, Length[errlst]}, {j, Length[errlst]}], 
  Message[covMatGen::nosymm, cormat]; Abort[]
]
   
errorFormat::usage = "errorFormat[type_String,errs_List]\n
 helps to determine how to symmetrize asymmetric uncertainties ('errs', a list) in input data according to 'type'.\n \
Allowed values of 'type' are: 'larger', 'smaller' and 'symmetric'."
errorFormat[type_String, errs_] := 
If[ListQ[errs],
 Which[type == "larger",  
 Max[errs],
   type == "smaller",
    Min[errs],
     type == "symmetric",
      Mean[errs]
      ],
   errs
]

matrixSymmetrize::usage = "matrixSymmetrize[mat]\n renders a numerically symmetric form of the matrix 'mat'. Mainly used to nullify "
matrixSymmetrize[(mat_)?MatrixQ] := 
Module[{upt = UpperTriangularize[mat]},
 upt + Transpose[upt] - DiagonalMatrix[Diagonal[mat]]
]

hessianMat::usage = "hessianMat[f,x_List]\n calculates the 'Hessian' of a scalar valued function 'f' with respect to components of a vector 'x'."
hessianMat[f_, (x_List)?VectorQ] := D[f, {x, 2}]

errorMat::usage = "errorMat[chsq,parlst_List,bflst]\n 
calculates the error matrix, given a \!\(\*SuperscriptBox[\(\[Chi]\), \(2\)]\) function 'chsq', list of parameters 'parlst', \
at the point represented by the replacement list(or Association) 'bflst'."
errorMat[chsq_, parlst_, bflst_] := 
Inverse[(1/2)*hessianMat[chsq, parlst] /. bflst]

errorInfo::usage = "errorInfo[errmat]\n gives the list of uncertainties and the correlation matrix, given a, error matrix 'errmat'."
errorInfo[(errmat_)?PositiveSemidefiniteMatrixQ] := 
Module[{di, corr}, di = Sqrt /@ Diagonal[errmat]; 
    corr = Table[errmat[[i,j]]/(di[[i]]*di[[j]]), {i, Length[errmat]}, {j, Length[errmat]}];
     {di, SparseArray[matrixSymmetrize[corr]]}
]
    
sigmaLevel::usage = "sigmaLevel[n]\n calculates the probability content for 'n' sigma confidence interval (comparing with the unit Normal distribution)."
sigmaLevel[sig_] := N[CDF[NormalDistribution[], sig] - CDF[NormalDistribution[], -sig]]

deltaChiSqVal::usage = 
  "deltaChiSqVal[q,n]\n calculates the \!\(\*SuperscriptBox[\(q\), \(th\)]\) quantile of a \!\(\*SuperscriptBox[\(\[Chi]\), \(2\)]\) distribution of degrees of freedom 'n'."
deltaChiSqVal[conflev_, dof_] := InverseCDF[ChiSquareDistribution[dof], conflev]

ConfLevel::usage = 
  "ConfLevel[n,x]\n gives the cumulative distribution function for a \!\(\*SuperscriptBox[\(\[Chi]\), \(2\)]\) distribution of degrees of freedom 'n' evaluated at x."
ConfLevel[dof_, chi2_] := CDF[ChiSquareDistribution[dof], chi2]

sigDigit::usage = "OptEx internal function."
sigDigit[numlst_List, sigdig_:2] := Min[(Last[MantissaExponent[#1]] & ) /@ numlst] - sigdig

errform[err_, rou_] := 
Module[{er1},
 er1 = (N[Round[#1, 10^rou]] & )[err];
  If[ListQ[err],
   StringJoin["\!\(\*SubsuperscriptBox[\(\), \( -", ToString[er1[[2]]], "\), \( +", ToString[er1[[1]]], "\)]\)"],
    StringJoin["\[PlusMinus]", ToString[er1]]
   ]
]

errorDisplay1::usage = "OptEx internal function."
errorDisplay1[numlst_List, sigdig_:2] := 
Module[{rouexpo = sigDigit[numlst, sigdig], er1},
 er1 = (N[Round[#1, 10^rouexpo]] & ) /@ numlst; 
 StringJoin[ToString[er1[[1]]], "\[PlusMinus]", StringRiffle[ToString /@ Drop[er1, 1], "\[PlusMinus]"]]
]

errorDisplay2::usage = "OptEx internal function."
errorDisplay2[numlst_List, sigdig_:2] := 
Module[{rouexpo = sigDigit[numlst, sigdig], er1, er2, dtstr},
 er1 = (N[Round[#1, 10^rouexpo]] & ) /@ numlst; er2 = ToString[er1[[1]]]; 
 dtstr = If[StringContainsQ[er2, "."],
            If[-rouexpo > StringLength[StringDrop[er2, StringPosition[er2, "."][[1,1]]]],
               StringJoin[StringTake[er2, StringPosition[er2, "."][[1,1]]], StringPadRight[StringDrop[er2, StringPosition[er2, "."][[1,1]]], -rouexpo, "0"]], 
               StringJoin[StringTake[er2, StringPosition[er2, "."][[1,1]]], StringDrop[er2, StringPosition[er2, "."][[1,1]]]]
           ]
          ]; 
 StringJoin[ToString[dtstr], "(", StringRiffle[(ToString[IntegerPart[#1]] & ) /@ (Drop[er1, 1]/10^rouexpo), ")("], ")"]
]

errorDisplay::usage = "errorDisplay[numlst_List,sigdig_:2,type_:1]\n displays the list of numbers 'numlst' with the first element as the central value and the rest as \
uncertainties.\n Number of significant digits kept is 'sigdig', with default value=2. If 'type'=1 and/or the error is symmetric, it is in the 'a\[PlusMinus]b' form,\n otherwise the \
second element is considered as the positive error and the third element as the negative error."
errorDisplay[numlst_List, sigdig_:2, type_:1] := 
If[Length[numlst] === 2,
 Switch[type, 1, errorDisplay1[numlst, sigdig], 2, errorDisplay2[numlst, sigdig]], 
 Module[{rouexpo = sigDigit[numlst, sigdig], er1},
     er1 = (N[Round[#1, 10^rouexpo]] & ) /@ numlst; 
     If[er1[[3]] === er1[[2]],
      Switch[type, 1, errorDisplay1[numlst[[1 ;; 2]], sigdig], 2, errorDisplay2[numlst[[1 ;; 2]], sigdig]], 
      StringJoin["\!\(\*SubsuperscriptBox[\(", ToString[er1[[1]]], "\), \( -", ToString[er1[[3]]], "\), \( +", ToString[er1[[2]]], "\)]\)"]
     ]
   ]
]

errorDisplayList::usage = "errorDisplayList[numlst_List,sigdig_:2,type_:1]\n 
displays the list of numbers 'numlst' with the first element as the central value and the rest as \
uncertainties.\n Number of significant digits kept is 'sigdig', with default value=2. If 'type'=1 and/or the error is symmetric, it is in the 'a\[PlusMinus]b' form,\n otherwise the \
second element is considered as the positive error and the third element as the negative error."
errorDisplayList[numlst_List, sigdig_:2, type_:1] := 
Module[{flst = Flatten[numlst], rouexpo, er1}, 
   rouexpo = sigDigit[flst, sigdig];
   er1 = (N[Round[#1, 10^rouexpo]] & ) /@ numlst;
   StringJoin[ToString[er1[[1]]], (errform[#1, rouexpo] & ) /@ Drop[er1, 1]]
]


dataForm::usage="dataForm[datalst_List]
 Given a correctly formatted list of data (containing name of the observable, central value and uncertainties), this creates an 'Association' which contains the correctly formatted dataset, usable in OptEx."
dataForm[datalst_List]:=
Module[{datls=If[AllTrue[datalst,Length[#]===Max[Length/@datalst]&],
				datalst,
				PadRight[#,Evaluate@Max[Length/@datalst]]&/@datalst
				]},
	Association[Table[datls[[i,1]]->
						Association["central"->datls[[i,2]],
									"uncertainties"->datls[[i,3;;]]
							],{i,Length[datls]}]]
]

correlationForm::usage="correlationForm[datalst_List,vals]
 transforms the correlation information 'vals' corresponding to the dataset 'datlst' to the correctly formatted form usable by OptEx."
correlationForm[datalst_List,vals_]:=
Module[{vls=If[AssociationQ[vals],
				Normal[vals],
				If[MatrixQ[vals],ArrayRules[vals],vals]
			]},
	KeyMap[First/@datalst[[#]]&,
		Association[(Sort[#[[1]]]->#[[2]])&/@DeleteCases[Select[vls,Length[Union[#[[1]]]]>1&],
													_->a_/;MatchQ[a,0]||MatchQ[a,0.]]]
	]
]

objectType::usage="objectType[obj_Association]
 differenciates between several types of Associations for OptEx to identify what type of object they are and how to act on them."
objectType[obj_?AssociationQ]:=
Module[{patlst={{"data","dataObject"},{"freeParams","paramObject"},{"observables","fitObject"},
				{"chisqMin","chiSqMinObject"},{"paramCL","CLObject"},{"batchType","batchFitObject"}},tpelst},
	tpelst=Pick[patlst,KeyExistsQ[obj,#[[1]]]&/@patlst];
	If[Length[tpelst]===1,tpelst[[1,2]],"assoObject"]
]

(*$icon = 
  Graphics[{Red,Disk[]},
     ImageSize -> Dynamic[{ (* this seems to be the standard icon size *)
         Automatic, 
         3.5 CurrentValue["FontCapHeight"]/AbsoluteCurrentValue[Magnification]
       }]
  ];*)

MakeBoxes[obj:assoObject[asc_?AssociationQ],form:(StandardForm|TraditionalForm)]^:=
Module[{above,below},
	above={BoxForm`SummaryItem[{"Type: ",objectType[asc]}]};
	below={BoxForm`SummaryItem[{"Keys: ",Keys[asc]}]};
	If[$VersionNumber>=11.2,
		BoxForm`ArrangeSummaryBox[assoObject,obj,None,above,below,form,"Interpretable"->Automatic],
		BoxForm`ArrangeSummaryBox[assoObject,obj,None,above,below,form]
	]
]
	
assoObject::usage="assoObject[asc_Association][property_String]
 searches for the Key 'key' in the Association 'asc' and returns the Value associated with it when 'key' is present. 'property'==\"Expand\" returns 'asc'. 'property'==\"Keys\" returns Keys of 'asc'. 'property'==\"Values\" returns Values of 'asc'.
 assoObject[asc_Association]
 In absence of the second argument it returns a SummaryBox item, showing specific information about the association, including what type of OptEx object it is. It can be applied on a second argument as explained above."
assoObject[asc_?AssociationQ][key_?StringQ]:=
If[key==="Expand",asc,If[key==="Keys",Keys[asc],If[key==="Values",Values[asc],asc[key]]]]

assoObjectQ::usage="A test of whether the argument is an 'assoObject'."
assoObjectQ[asc_]:=MatchQ[Head[asc],assoObject]


dataObject::usage="dataObject[datalst_List,correlations_List:{}]
 prepares an 'assoObject' from the list of observables into an optimizble form usable by OptEx, and assigns the objectType 'dataObject' to it."
dataObject[datalst_List,correlations_List:{}]:=
assoObject[
If[Length[correlations]===0,
	Association["data"->dataForm[datalst]],
	Association[{"data"->dataForm[datalst],"correlations"->Evaluate[correlationForm[datalst,#]&/@correlations]}]
]]
dataObjectQ::usage="A test for an 'assoObject' of whether is it a 'dataObject'."
dataObjectQ[asc_?assoObjectQ]:=KeyExistsQ[asc["Expand"],"data"]


addData::usage="Define"
addData[dataobj_?dataObjectQ,newdata_List,correlations_:{}]:=
If[Length[newdata]===0,
	dataobj,
	assoObject[
	If[Length[correlations]===0,
		Join[Association["data"->Evaluate[Join[dataobj["data"],dataForm[newdata]]]],
			KeyDrop[dataobj["Expand"],{"data"}]],
		Module[{newcorrs=If[KeyExistsQ[dataobj["Expand"],"correlations"],
							Join[dataobj["correlations"],correlations,2],
							correlations
						]},
			Association[{"data"->Join[dataobj["data"],dataForm[newdata]],"correlations"->newcorrs}]
		]
	]]
]

removeData::usage="Define"
removeData::nodata="No list is specified with elements to be dropped."
removeData[dataobj_?dataObjectQ,dropdata_List]:=
If[Length[dropdata]===0,
	Message[removeData::nodata];Abort[],
	Module[{formdat={#}&/@dropdata,dats=dataobj["data"],cors,newcors},
		cors=If[KeyExistsQ[dataobj["Expand"],"correlations"],dataobj["correlations"],{}];
		newcors=If[Length[cors]===0,
				{},
				If[AssociationQ[First@cors],
					Table[KeyTake[cors[[i]],Select[Keys[cors[[i]]],ContainsNone[#,Keys[dats][[dropdata]]]&]],{i,Length[cors]}],
					(SparseArray[Delete[#,formdat]&/@Delete[Normal@#,formdat]])&/@cors
				]
			];
		assoObject[
		If[Length[newcors]===0,
			Association["data"->Delete[dats,formdat]],
			Association["data"->Delete[dats,formdat],"correlations"->newcors]
		]]
	]
]


freeParamForm::usage="freeParamForm[paramlst_List]
 Given a correctly formatted list of free fit parameters (containing name of the parameter and optionally the ranges for search), this creates an 'Association', usable in OptEx."
freeParamForm[paramlst_List]:=
Association[Table[If[StringQ[paramlst[[i]]],
					paramlst[[i]],
					paramlst[[i,1]]
					]->Association[{"type"->"free",If[StringQ[paramlst[[i]]],
													"range"->"free",
													"range"->paramlst[[i,2]]
												]
					}],{i,Length[paramlst]}]
]

nuisanceForm::usage="nuisanceForm[nuislst_List,nuiscorrs_List:{}]
 Given a correctly formatted list of nuisance parameters (containing names and uncertainties of the parameters) and the correlations between them, this creates an 'Association', usable in OptEx."
nuisanceForm[nuislst_List,nuiscorrs_List:{}]:=
Module[{parls=Append["type"->"nuisance"]/@dataForm[nuislst]},
		If[Length[nuiscorrs]===0,
			Association[{"data"->parls}],
			Association[{"data"->parls,"correlations"->Evaluate[correlationForm[nuislst,#]&/@nuiscorrs]}]
		]
]

paramObject::usage="paramObject[freeparlst_List,nuislst_List:{},nuiscorr_List:{}]
 prepares an 'assoObject' from the list of free and nuisance parameters, and correlations of the nuisance parameters, into an optimizble form usable by OptEx, and assigns the objectType 'paramObject' to it."
paramObject[freeparlst_List,nuislst_List:{},nuiscorr_List:{}]:=
Module[{frees,nuiss},
		frees=freeParamForm[freeparlst];
		nuiss=If[Length@nuislst===0,
				Null,
				nuisanceForm[nuislst,nuiscorr]
				];
	assoObject[
	If[nuiss===Null,
		Association[{"freeParams"->frees}],
		Association[{"freeParams"->frees,"nuisanceParams"->assoObject[nuiss]}]
	]]
]
paramObjectQ::usage="A test for an 'assoObject' of whether is it a 'paramObject'."
paramObjectQ[asc_?assoObjectQ]:=KeyExistsQ[asc["Expand"],"freeParams"]

paramList[obj_?paramObjectQ]:=
Join[Keys@obj["freeParams"],
	If[KeyExistsQ[obj["Expand"],"nuisanceParams"],
		Keys@obj["nuisanceParams"]["data"],
		{}
	]
]


addParam::usage="Define"
addParam[paramobj_?paramObjectQ,newparam_List,correlations_:{}]:=
If[Length[newparam]===0,
	paramobj,
	assoObject[
	Module[{frees=Select[newparam,Length[#]<3&],nuiss=Select[newparam,Length[#]==3&],frees2,nuiss2,nuiss3},
		frees2=Join[paramobj["freeParams"],If[Length[frees]>0,freeParamForm[frees],<||>]];
		nuiss2=If[Length[nuiss]>0,nuisanceForm[nuiss,correlations],Association[{"data"-><||>,"correlations"->{}}]];
		nuiss3=If[KeyExistsQ[paramobj["Expand"],"nuisanceParams"],
				Association[{"data"->Join[paramobj["nuisanceParams"]["data"],nuiss2["data"]],
							"correlations"->Join[paramobj["nuisanceParams"]["correlations"],nuiss2["correlations"],2]
				}],
				nuiss2
				];
		If[Length@nuiss3===0,
		Association[{"freeParams"->frees2}],
		Association[{"freeParams"->frees2,"nuisanceParams"->assoObject@nuiss3}]
		]
	]]
]

removeParam::usage="Define"
removeParam[paramobj_?paramObjectQ,dropparam_List]:=
If[Length[dropparam]===0,
	paramobj,
	assoObject[
	Module[{frees=KeyDrop[paramobj["freeParams"],dropparam],nuiss=paramobj["nuisanceParams"],nuiss2},
		nuiss2=If[KeyExistsQ[nuiss["Expand"],"correlations"],
				Association["data"->KeyDrop[nuiss["data"],dropparam],
							"correlations"->Map[KeyDrop[#,
													If[(Intersection[#,dropparam]=!={}),#,$nothing]&/@Keys[#]
												]&,
												nuiss["correlations"]
											]
							],
				Association["data"->KeyDrop[nuiss["data"],dropparam]]
				];
		Association[{"freeParams"->frees,"nuisanceParams"->assoObject@nuiss2}]
	]]
]


correlationCreate::usage="correlationCreate[dataobj_?dataObjectQ]
 returns a SparseArray depicting the correlation matrix of the dataset contained in 'dataobj'."
correlationCreate[dataobj_?dataObjectQ]:=
Module[{offd,ky=Keys[dataobj["data"]],vals,dim=Length[dataobj["data"]]},
	vals=KeyMap[Position[ky,#][[1,1]]&/@#&,#]&/@(dataobj["correlations"]);
	offd=SparseArray[Normal@#,{dim,dim}]&/@vals;
	SparseArray[IdentityMatrix[dim]+#+Transpose[#]]&/@offd
]

MakeBoxes[obj:listObject[data_?ListQ],form:(StandardForm|TraditionalForm)]^:=
Module[{above,below(*,icn*)},
	above={BoxForm`SummaryItem[{"Length: ",Length[data]}]};
	below={BoxForm`SummaryItem[{"Dimensions: ",Dimensions[data]}]};
	If[$VersionNumber>=11.2,
		BoxForm`ArrangeSummaryBox[listObject,obj,None,above,below,form,"Interpretable"->Automatic],
		BoxForm`ArrangeSummaryBox[listObject,obj,None,above,below,form]
	]
]

listObject::usage="listObject[data_List][\"Expand\"] returns the list 'data'.
 listObject[data_List] returns a SummaryBox item, showing specific information about 'data'. It can be used to stop large lists from displaying in the output."
listObject::noform="`1` is not a valid argument for a 'listObject'."
listObject[data_?ListQ][property_String]:=If[property==="Expand",data,Message[listObject::noform,property]]

Options[covMatForm]={errorType->"symmetric"};

covMatForm::usage="covMatForm[datobj]
 creates a covariance matrix from the dataObject 'datobj'. In case of multiple types of uncertainties present in datobj, separate covariance matrices are formed and are added."
covMatForm[datobj_?dataObjectQ,opts:OptionsPattern[]]:=
Module[{uns=Lookup[Values[datobj["data"]],"uncertainties"],
		cors=If[KeyExistsQ[datobj["Expand"],"correlations"],
				If[MatrixQ[datobj["correlations"][[1]]],
					datobj["correlations"],
					correlationCreate[datobj]
				],
				{}
			]},
	If[Length[cors]===0,
	Total@Table[covMatGen[errorFormat[OptionValue[errorType],#[[i]]]&/@uns,IdentityMatrix[Length[uns]]],
				{i,Length[uns[[1]]]}],
	Total@Table[covMatGen[errorFormat[OptionValue[errorType],#[[i]]]&/@uns,cors[[i]]],
				{i,Length[cors]}]
	]
]

Options[populateData]=Options[covMatForm];

populateData::usage="populateData[dataobj,n]
 returns a listObject conataining a list (of length 'n') of pseudorandom variates from the Multinormal distribution representing the 'dataobj'."
populateData[dataobj_?dataObjectQ,pts_,opts:OptionsPattern[]]:=
listObject[RandomVariate[MultinormalDistribution[Values[Lookup[#,"central"]&/@dataobj["data"]],
			covMatForm[dataobj,Evaluate[FilterRules[{opts},Options[covMatForm]]]]],
			pts]
]

Options[fitObject]=Options[covMatForm]~Join~{simulData->False,points->100,numericFunction->False};

fitObject::usage="fitObject[dataobj,paramobj,theoryList_List:{}]
 Given the dataObject 'dataobj', paramObject 'paramobj', and optional list of theoretical expressions 'theoryList', this prepares an 'assoObject' into optimizble form, and assigns the objectType 'fitObject' to it."
fitObject[dataobj_?dataObjectQ,paramobj_?paramObjectQ,theoryList_:{},opts:OptionsPattern[]]:=
Module[{dat2=assoObject@Association[{"data"->dataobj["data"],"correlations"->correlationCreate[dataobj]}],par2},
	par2=assoObject@Association[Join[{"freeParams"->paramobj["freeParams"]},
							If[KeyExistsQ[paramobj["Expand"],"nuisanceParams"],
								{"nuisanceParams"->assoObject@Association[Join[{"data"->paramobj["nuisanceParams"]["data"]},
																		If[KeyExistsQ[paramobj["nuisanceParams"]["Expand"],"correlations"],
																			{"correlations"->correlationCreate[paramobj["nuisanceParams"]]},
																			{}
																		]]]},
								{}
							]]];
	assoObject[
	Append[
		Append[
			If[Length[theoryList]===0,
				Association[{"observables"->dat2,"parameters"->par2}],
				Association[{"observables"->dat2,"parameters"->par2,"theory"->theoryList}]
			],
			If[OptionValue[simulData],
				"simulData"->populateData[dataobj,
										OptionValue[points],
										Evaluate[FilterRules[{opts},Options[populateData]]]],
				<||>
			]
		],
		If[OptionValue[numericFunction],"numericFunction"->True,<||>]
	]]
]
fitObjectQ::usage="A test for an 'assoObject' of whether is it a 'fitObject'."
fitObjectQ[asc_?assoObjectQ]:=KeyExistsQ[asc["Expand"],"observables"]


vecForm::usage="vecForm[datobj]
 creates a vector using the supplied dataObject - 'dataobj', in the form (\!\(\*SubscriptBox[\(O\), \(i\)]\)-\!\(\*SubscriptBox[\(Ex\), \(i\)]\)), where \!\(\*SubscriptBox[\(O\), \(i\)]\) is the \!\(\*SuperscriptBox[\(i\), \(th\)]\) observable identifier and \!\(\*SubscriptBox[\(Ex\), \(i\)]\) is the corresponding central value of the experimental result.
vecForm[datobj,thlst_List]
 creates a vector as above and replaces the observable identifiers with the replacement list 'thlst'."
vecForm::leng="Length mismatch between the provided data-list and theory list. Please check. Evaluation aborted."
vecForm[datobj_?dataObjectQ,thlst_:{}]:=
If[Length[thlst]===0,
	ToExpression/@Keys[datobj["data"]],
	If[Length[datobj["data"]]===Length[thlst],
		Values[thlst],
		Message[vecForm::leng];Abort[]
	]
]-(Lookup[#,"central"]&/@Values[datobj["data"]])

(*Options[vecFormP]={arrayName\[Rule]obAr};*)

vecFormP::usage="Similar to vecForm, but is only formed for pseudo-experiments, required for p-values obtained from Monte-Carlo procedure."
vecFormP[datobj_?dataObjectQ,thlst_:{}(*,opts:OptionsPattern[]*)]:=
If[Length[thlst]===0,
	ToExpression/@Keys[datobj["data"]],
	Values[thlst]
]-Array[obAr,Length[datobj["data"]]]

Options[chiSqForm]=Options[covMatForm]~Join~{"Simplify"->False,"Chop"->False,extended->False};

chiSqForm::usage="chiSqForm[datobj]
 creates a \!\(\*SuperscriptBox[\(\[Chi]\), \(2\)]\) function using the supplied dataObject - 'dataobj', in the form (\!\(\*SubscriptBox[\(O\), \(i\)]\)-\!\(\*SubscriptBox[\(Ex\), \(i\)]\)).\!\(\*SuperscriptBox[\(C\), \(-1\)]\).(\!\(\*SubscriptBox[\(O\), \(i\)]\)-\!\(\*SubscriptBox[\(Ex\), \(i\)]\)), where \!\(\*SubscriptBox[\(O\), \(i\)]\) is the \!\(\*SuperscriptBox[\(i\), \(th\)]\) observable identifier,
 \!\(\*SubscriptBox[\(Ex\), \(i\)]\) is the corresponding central value of the experimental result, and C is the covariance matrix of the measured values of the observavles.
chiSqForm[datobj,thlst_List]
 creates \!\(\*SuperscriptBox[\(\[Chi]\), \(2\)]\) as above and replaces the observable identifiers with the replacement list 'thlst'."
chiSqForm[datobj_?dataObjectQ,thlst_List:{},opts:OptionsPattern[]]:=
If[OptionValue[extended],
	Module[{vecobj,covm,chst,invC,sum0,offs,sum1,sum10},
		vecobj=vecForm[datobj,thlst];
		covm=covMatForm[datobj,Evaluate[FilterRules[{opts}, Options[covMatForm]]]];
		invC=Inverse[covm];
		sum0=Total[invC,-1];
		offs=Log[sum0/(2\[Pi])]+Log[Det[2\[Pi]*covm]];
		sum1=vecobj.invC.vecobj;
		sum10=Total[vecobj.invC];
		chst=sum1-sum10^2/sum0+offs;
		If[OptionValue["Chop"],
			If[OptionValue["Simplify"],Chop@Simplify[chst],Chop@chst],
			If[OptionValue["Simplify"],Simplify[chst],chst]
		]
	],
	Module[{vecobj,covm,chst},
		vecobj=vecForm[datobj,thlst];
		covm=covMatForm[datobj,Evaluate[FilterRules[{opts}, Options[covMatForm]]]];
		chst=vecobj.Inverse[covm].vecobj;
		If[OptionValue["Chop"],
			If[OptionValue["Simplify"],Chop@Simplify[chst],Chop@chst],
			If[OptionValue["Simplify"],Simplify[chst],chst]
		]
	]
]

Options[chiSqFormFit]=Options[chiSqForm]~Join~{nuisanceterm->True};

chiSqFormFit::usage="chiSqFormFit[fitobj] creates a \!\(\*SuperscriptBox[\(\[Chi]\), \(2\)]\) function using the supplied fitObject - 'fitobj'."
chiSqFormFit[fitobj_?fitObjectQ,opts:OptionsPattern[]]:=
Module[{dataobj=fitobj["observables"],chsqnuis,chsq},
	chsqnuis=If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"]&&OptionValue[nuisanceterm],
				chiSqForm[fitobj["parameters"]["nuisanceParams"],{},Evaluate[FilterRules[{opts},Options[chiSqForm]]]],
				0];
	chsq=If[KeyExistsQ[fitobj["Expand"],"theory"],
		chiSqForm[dataobj,fitobj["theory"],Evaluate[FilterRules[{opts},Options[chiSqForm]]]],
		chiSqForm[dataobj,{},Evaluate[FilterRules[{opts},Options[chiSqForm]]]]
		];
	If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"]&&OptionValue[nuisanceterm],
		chsq+chsqnuis,
		If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"],
			Module[{nuival=fitobj["parameters"]["nuisanceParams"]["data"]},
				chsq/.AssociationThread[ToExpression/@Keys[nuival],Values[Lookup[#,"central"]&/@(nuival)]]
			],
			chsq
		]
	]
]


Options[chiSqFormP]={"Simplify"->False};

chiSqFormP::usage="Similar to chiSqForm, but is only formed for pseudo-experiments, required for p-values obtained from Monte-Carlo procedure."
chiSqFormP[datobj_?dataObjectQ,thlst_List:{},opts:OptionsPattern[]]:=
Module[{vecobj,chst},
	vecobj=vecFormP[datobj,thlst];
	chst=vecobj.vecobj;
	If[OptionValue["Simplify"],Simplify[chst],chst]
]

Options[chiSqFormFitP]=Options[chiSqFormP]~Join~{nuisanceterm->True};

chiSqFormFitP::usage="Similar to chiSqFormFit, but is only formed for pseudo-experiments, required for p-values obtained from Monte-Carlo procedure."
chiSqFormFitP[fitobj_?fitObjectQ,opts:OptionsPattern[]]:=
Module[{dataobj=fitobj["observables"],chsq,chsqnuis},
	chsqnuis=
		If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"]&&OptionValue[nuisanceterm],
			chiSqFormP[fitobj["parameters"]["nuisanceParams"],{},Evaluate[FilterRules[{opts},Options[chiSqFormP]]]],
			0
		];
	chsq=If[KeyExistsQ[fitobj["Expand"],"theory"],
		chiSqFormP[dataobj,fitobj["theory"],Evaluate[FilterRules[{opts},Options[chiSqFormP]]]],
		chiSqFormP[dataobj,{},Evaluate[FilterRules[{opts},Options[chiSqFormP]]]]
		];
	If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"]&&OptionValue[nuisanceterm],
		chsq+chsqnuis,
		If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"],
			Module[{nuival=fitobj["parameters"]["nuisanceParams"]["data"]},
				chsq/.AssociationThread[ToExpression/@Keys[nuival],Values[Lookup[#,"central"]&/@(nuival)]]
			],
			chsq
		]
	]
]


Options[rangeForm]={nuisanceterm->True};

rangeForm::usage="rangeForm[fitobj,opts_String]
 creates a list of ranges for the parameters to be used for minimization of the \!\(\*SuperscriptBox[\(\[Chi]\), \(2\)]\) function, using the supplied fitObject - 'fitobj'. 'opts' specifies the type of uncertainties."
rangeForm[fitobj_?fitObjectQ,opts_String:"symmetric",OptionsPattern[]]:=
Module[{nuisobjs},
		nuisobjs=If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"]&&OptionValue[nuisanceterm],
					{ToExpression[#[[1]]],
					#[[2]]["central"]-errorFormat[opts,#[[2]]["uncertainties"]],
					#[[2]]["central"]+errorFormat[opts,#[[2]]["uncertainties"]]}&/@
											Normal@(fitobj["parameters"]["nuisanceParams"]["data"]),
					{}];
		Join[If[#[[2]]["range"]==="free",
				ToExpression[#[[1]]],
				{ToExpression[#[[1]]],Sequence@@#[[2]]["range"]}]&/@Normal@(fitobj["parameters"]["freeParams"]),
				nuisobjs]
]

Options[constraintForm]={nuisanceterm->True};

constraintForm::usage="constraintForm[fitobj,opts_String]
 creates a constraint condition for the nuisance parameters to be used for minimization of the \!\(\*SuperscriptBox[\(\[Chi]\), \(2\)]\) function, using the supplied fitObject - 'fitobj'. This ensures reasonable fit values of the  'opts' specifies the type of uncertainties."
constraintForm[fitobj_?fitObjectQ,opts_String:"symmetric",OptionsPattern[]]:=
If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"]&&OptionValue[nuisanceterm],
	{And@@(((#[[2]]["central"]-errorFormat[opts,#[[2]]["uncertainties"]])<=
		ToExpression[#[[1]]]<=
		(#[[2]]["central"]+errorFormat[opts,#[[2]]["uncertainties"]]))&/@
								Normal@(fitobj["parameters"]["nuisanceParams"]["data"]))},
	{}
	]

Options[chiSqMinimForm]=Options[chiSqFormFit]~Join~Options[NMinimize]~Join~{extraConstraint->{},nuisConstraint->False};

chiSqMinimForm::usage="chiSqMinimForm[fitobj]
 creates a \!\(\*SuperscriptBox[\(\[Chi]\), \(2\)]\) function in cito, minimizes it, and returns the best-fit results and the fitted minimum."
chiSqMinimForm[fitobj_?fitObjectQ,opts:OptionsPattern[]]:=
Module[{chsq,vars,contr},
		chsq=chiSqFormFit[fitobj,Evaluate[FilterRules[{opts},Options[chiSqFormFit]]]];
		contr=If[OptionValue[nuisConstraint],
				If[Length[OptionValue[extraConstraint]]===0,
					constraintForm[fitobj,OptionValue[errorType],Evaluate[FilterRules[{opts},Options[constraintForm]]]],
					{And@@Join[constraintForm[fitobj,OptionValue[errorType],Evaluate[FilterRules[{opts},Options[constraintForm]]]],
						OptionValue[extraConstraint]]}
				],
				If[Length[OptionValue[extraConstraint]]===0,
					{},
					OptionValue[extraConstraint]
				]
			];
		vars=rangeForm[fitobj,OptionValue[errorType],Evaluate[FilterRules[{opts},Options[rangeForm]]]];
		NMinimize[{chsq,Sequence@@contr},Evaluate@vars,Evaluate[FilterRules[{opts}, Options[NMinimize]]]]
]


dofSimple::usage="dofSimple[fitobj]
 returns the difference of number of observables and the number of effective parameters, given the fitObject 'fitobj'."
dofSimple[fitobj_?fitObjectQ]:=
Length[fitobj["observables"]["data"]]-Length[fitobj["parameters"]["freeParams"]]

Options[pSimulData]=Join[Options[covMatForm],
						{"Simplify"->False,nuisanceterm->True,extraConstraint->{},
							parallel->True,kernels->All,prompt->True,simulData->False,points->500},
						Options[NMinimize]];

pSimulData::usage="pSimulData[fitobj]
 creates a set of pseudo-experiments corresponding to the fitObject 'fitobj', minimizes the corresponding \!\(\*SuperscriptBox[\(\[Chi]\), \(2\)]\) functions, and lists the minimum values in a listObject. This is used to calculate the p-value of any fit using Monte-carlo method.
pSimulData[fitobj,replst]
 given a replacement list of parameters and values ('replst'), this first sets the values of those parameters at those given values, and then performs the step explained above."
pSimulData[fitobj_?fitObjectQ,replst_:{},opts:OptionsPattern[]]:=
Module[{chsq,contr,vars,obpt,chlst},
		contr=If[Length[OptionValue[extraConstraint]]===0,
				constraintForm[fitobj,OptionValue[errorType],Evaluate[FilterRules[{opts},Options[constraintForm]]]],
				{And@@Join[constraintForm[fitobj,OptionValue[errorType],
												Evaluate[FilterRules[{opts},Options[constraintForm]]]],
					OptionValue[extraConstraint]]}
				];
		vars=rangeForm[fitobj,Evaluate[FilterRules[{opts},Options[rangeForm]]]];
		obpt=If[KeyExistsQ[fitobj["Expand"],"simulData"]&&MatchQ[OptionValue[simulData],False],
				fitobj["simulData"]["Expand"],
				populateData[fitobj["observables"],OptionValue[points],
								Evaluate[FilterRules[{opts},Options[populateData]]]]["Expand"]
			];
		chsq=If[Length[replst]===0,
				chiSqFormFitP[fitobj,Evaluate[FilterRules[{opts},Options[chiSqFormFitP]]]]
				(*/.(#["central"]&/@fitobj["parameters"]["nuisanceParams"]["data"])*),
				chiSqFormFitP[fitobj,Evaluate[FilterRules[{opts},Options[chiSqFormFitP]]]]/.replst
				(*/.(#["central"]&/@fitobj["parameters"]["nuisanceParams"]["data"])*)
			];
		If[OptionValue[prompt],
			If[$KernelCount===0,
				CloseKernels[];If[OptionValue[kernels]===All,
									LaunchKernels[],
									LaunchKernels[OptionValue[kernels]]
								]
			];
			PrintTemporary["Scanning for p-value in progress ... "];
			PrintTemporary["Parallel Processing: True",
							If[$KernelCount===0,
								"",
								"\nParallel Kernels: "<>ToString[$KernelCount]
							]
			];
			PrintTemporary["Elapsed time: ",Dynamic[Clock[{0,Infinity,1}]]," seconds"]
		];
		chlst=ParallelMap[Quiet@NMinimize[{chsq/.AssociationThread[Array[obAr,Length[fitobj["observables"]["data"]]],
																	#],Sequence@@contr},
										Evaluate@vars,
										Evaluate[FilterRules[{opts}, Options[NMinimize]]]
									][[1]]&,
						obpt,
						DistributedContexts->{"OptEx`","OptEx`Private`","Global`"}];
		listObject[Append[chlst,
					Quiet@NMinimize[{chsq/.AssociationThread[Array[obAr,Length[fitobj["observables"]["data"]]],
															Values[Map[Lookup["central"],
																		fitobj["observables"]["data"]]]
													],
									Sequence@@contr},
									Evaluate@vars,Evaluate[FilterRules[{opts}, Options[NMinimize]]]
								][[1]]]
			]
]

pValueMC::usage="pValueMC[datalst,minval]
 given a list of \!\(\*SubsuperscriptBox[\(\[Chi]\), \(min\), \(2\)]\) values ('datalst'), this calculates the p-value of the fit, for which the minimum is 'minval'. Corresponding uncertainties are also quoted. datalst is generally the output of pSimulData."
pValueMC[datalst_?VectorQ,minval_]:=
Module[{pdir},
	pdir=N[Length[Select[datalst,#>minval&]]/Length[datalst]];
	{pdir,Sqrt[(pdir*(1-pdir))/Length[datalst]]}
]

Options[pValue]=Options[pSimulData]~Join~{ptype->"Simple"};

pValue::usage="pValue[fitobj,minval]
 calculates the p-value of the fit corresponding the fitObject 'fitobj' and the \!\(\*SubsuperscriptBox[\(\[Chi]\), \(min\), \(2\)]\) value 'minval'."
pValue[fitobj_?fitObjectQ,minval_,opts:OptionsPattern[]]:=
Switch[OptionValue[ptype],
	"Simple",
	If[ListQ[minval],
		1-ConfLevel[dofSimple[fitobj],Evaluate[chiSqFormFit[fitobj,Evaluate[FilterRules[{opts}, Options[chiSqFormFit]]]]/.minval]],
		1-ConfLevel[dofSimple[fitobj],minval]
	],
	"MC",
	Module[{semc},
		semc=pSimulData[fitobj,{},Evaluate[FilterRules[{opts},Options[pSimulData]]]]["Expand"];
		pValueMC[semc,minval]
	]
]


Options[chiSqMinObject]=Join[Options[covMatForm],{"Simplify"->False,nuisanceterm->True,extraConstraint->{},nuisConstraint->False,
							parallel->True,kernels->All,prompt->True,simulData->False,points->500,ptype->"Simple"},Options[NMinimize]];

chiSqMinObject::usage="chiSqMinObject[fitobj]
 takes a fitObject 'fitobj' as inpput, creates a \!\(\*SuperscriptBox[\(\[Chi]\), \(2\)]\), minimizes it, obtains the goodness-of-fit depending the OptionValues, and creates an assoObject of a specific type (chiSqMinObject) with all relevant information for the fit,
 which can then be used for parameter estimation."
chiSqMinObject::nofit="Neither any fit object nor any minimization result is supplied. Evaluation Aborted."
chiSqMinObject[fitobj_?fitObjectQ,opts:OptionsPattern[]]:=
Module[{chsq,vars,contr,cmin,pdat,nuis,ftob(*,dmd*)},
		chsq=chiSqFormFit[fitobj,Evaluate[FilterRules[{opts},Options[chiSqFormFit]]]];
		contr=If[OptionValue[nuisConstraint],
				If[Length[OptionValue[extraConstraint]]===0,
					constraintForm[fitobj,OptionValue[errorType],Evaluate[FilterRules[{opts},Options[constraintForm]]]],
					{And@@Join[constraintForm[fitobj,OptionValue[errorType],Evaluate[FilterRules[{opts},Options[constraintForm]]]],
						OptionValue[extraConstraint]]}
				],
				If[Length[OptionValue[extraConstraint]]===0,
					{},
					OptionValue[extraConstraint]
				]
			];
		vars=rangeForm[fitobj,OptionValue[errorType],Evaluate[FilterRules[{opts},Options[rangeForm]]]];
		cmin=NMinimize[{chsq,Sequence@@contr},Evaluate@vars,Evaluate[FilterRules[{opts}, Options[NMinimize]]]];
		nuis=If[OptionValue[nuisanceterm]&&KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"],
				KeyTake[cmin[[2]],ToExpression/@Keys[fitobj["parameters"]["nuisanceParams"]["data"]]],
				{}
			];
		ftob=If[OptionValue[simulData],
				assoObject[Append[KeyDrop[fitobj["Expand"],"simulData"],
								"simulData"->populateData[fitobj["observables"],OptionValue[points],
													Evaluate[FilterRules[{opts},Options[populateData]]]]
								]
						],
				fitobj
			];
		pdat=If[OptionValue[ptype]==="Simple",
				{},
				pSimulData[ftob,(*nuis*){},Evaluate[FilterRules[{opts},Options[pSimulData]]]]
			];
		(*dmd=If[OptionValue[ptype]==="Simple",
				{},
				findDistParams[pdat["Expand"],GammaDistribution[gamdis\[Alpha],gamdis\[Beta]],
									Evaluate[FilterRules[{opts},Options[findDistParams]]]]
			];*)
		assoObject[
		Association[Join[{"fitObject"->ftob,
					"chisqMin"->cmin[[1]],
					"fitResult"->cmin[[2]],
					"fitQuality"->Association[Join[{"dofSimple"->dofSimple[fitobj],
											"pSimple"->pValue[fitobj,cmin[[1]],ptype->"Simple"]},
											If[OptionValue[ptype]==="Simple",
												{},
												{"pMC"->pValueMC[pdat["Expand"],Last[pdat["Expand"]]](*,
												"dofMCdata"\[Rule]dmd,
												"dofMC"\[Rule]2*dmd[gamdis\[Alpha]]*)}
											]]
										],
					"NMinimizeOptions"->Evaluate[FilterRules[{opts}, Options[NMinimize]]],
					"errorType"->OptionValue[errorType],
					"keepnuisance"->OptionValue[nuisanceterm]},
					If[Length[OptionValue[extraConstraint]]===0,
						{},
						{"extraConstraint"->OptionValue[extraConstraint]}
					]
			]]
		]
]
chiSqMinObjectQ::usage="Tests whether an assoObject is a chiSqMinObject or not."
chiSqMinObjectQ[asc_?assoObjectQ]:=KeyExistsQ[asc["Expand"],"chisqMin"]


(* ::Input::Initialization:: *)
batchFitObjectQ::usage="Tests whether an assoObject is a batchFitObject or not."
batchFitObjectQ[asc_?assoObjectQ]:=KeyExistsQ[asc["Expand"],"batchType"]
vartemp[vars_,elem_]:=Select[vars,MemberQ[elem,#[[1]]]&]

Options[batchFitParam]=Options[chiSqMinObject];

batchFitParam::usage="batchFitParam[fitobj,varkey,varlst]."
batchFitParam[fitobj_?fitObjectQ,parlst_,opts:OptionsPattern[]]:=
Module[{chsq,vars,contr,cmin,pmast,noo},
	pmast=Join[ToExpression/@(Keys@fitobj["parameters"]["freeParams"]),
			If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"],
				ToExpression[Keys[fitobj["parameters"]["nuisanceParams"]["data"]]],
				{}
			]
		];
	noo=Length[fitobj["observables"]["data"]];
	chsq=chiSqFormFit[fitobj,Evaluate[FilterRules[{opts},Options[chiSqFormFit]]]];
	contr=If[OptionValue[nuisConstraint],
			If[Length[OptionValue[extraConstraint]]===0,
				constraintForm[fitobj,OptionValue[errorType],Evaluate[FilterRules[{opts},Options[constraintForm]]]],
				{And@@Join[constraintForm[fitobj,OptionValue[errorType],Evaluate[FilterRules[{opts},Options[constraintForm]]]],
					OptionValue[extraConstraint]]}
			],
			If[Length[OptionValue[extraConstraint]]===0,
					{},
					OptionValue[extraConstraint]
				]
		];
	vars=rangeForm[fitobj,OptionValue[errorType],Evaluate[FilterRules[{opts},Options[rangeForm]]]];
	cmin=ParallelMap[With[{repl=Evaluate[(#->0)&/@Complement[pmast,#]]},
		NMinimize[{Evaluate[chsq/.repl],Sequence@@Evaluate[contr/.repl]},
					Evaluate[vartemp[vars,#]],Evaluate[FilterRules[{opts}, Options[NMinimize]]]]
	]&,parlst,DistributedContexts->{"OptEx`","OptEx`Private`","Global`"},Method->"FinestGrained"];
	assoObject[
		Association[Join[{"fitObject"->fitobj,
					"chisqMins"->First/@cmin,
					"fitResults"->Last/@cmin,
					"fitQualities"->Association[{
							"dofSimple"->noo-Evaluate[Length/@parlst],
							"pSimple"->Table[1-ConfLevel[Evaluate@(Length[fitobj["observables"]["data"]]-Length[parlst[[i]]]),
														cmin[[i,1]]],
											{i,Length@parlst}]}],
					"NMinimizeOptions"->Evaluate[FilterRules[{opts}, Options[NMinimize]]],
					"errorType"->OptionValue[errorType],
					"keepnuisance"->OptionValue[nuisanceterm]},
					If[Length[OptionValue[extraConstraint]]===0,
						{"batchType"->"Params"},
						{"batchType"->"Params","extraConstraint"->OptionValue[extraConstraint]}
					]
				]
	]
	]
]


(* ::Input::Initialization:: *)
FitFromBatch[obj_?batchFitObjectQ,case_]:=
Module[{fitobj=obj["fitObject"],fitnew,pars=Keys@obj["fitResults"][[case]],frees,dpars,nuis},
frees=If[StringQ[Keys[fitobj["parameters"]["freeParams"]][[1]]],
		KeyTake[fitobj["parameters"]["freeParams"],ToString/@pars],
		KeyTake[fitobj["parameters"]["freeParams"],pars]
	];
(* This next line needs to be corrected .... the correlation *)
nuis=If[KeyExistsQ[fitobj["parameters"][[1]],"nuisanceParams"],
		assoObject@Association[{"data"->If[StringQ[Keys[fitobj["parameters"]["nuisanceParams"]["data"]][[1]]],
										KeyTake[fitobj["parameters"]["nuisanceParams"]["data"],ToString/@pars],
										KeyTake[fitobj["parameters"]["nuisanceParams"]["data"],pars]
									](* , corelation goes here *)}]
	];
dpars=If[StringQ[paramList[fitobj["parameters"]][[1]]],
		ToExpression/@Complement[paramList[fitobj["parameters"]],ToString/@pars],
		Complement[paramList[fitobj["parameters"]],pars]
	];
fitnew=assoObject@Join[KeyTake[fitobj[[1]],{"observables","simulData"}],
	Association[{"theory"->fitobj["theory"]/.((#->0)&/@dpars),
				"parameters"->If[KeyExistsQ[fitobj["parameters"][[1]],"nuisanceParams"],
								assoObject[Association[{"freeParams"->frees,"nuisanceParams"->nuis}]],
								assoObject[Association["freeParams"->frees]]
							]}]];
assoObject[Join[Association[{"fitObject"->fitnew,
								"chisqMin"->obj["chisqMins"][[case]],
								"fitResult"->obj["fitResults"][[case]],
								"fitQuality"->Association[{"dofSimple"->obj["fitQualities"]["dofSimple"][[case]],
													"pSimple"->obj["fitQualities"]["pSimple"][[case]]}]}],
			If[KeyExistsQ[obj[[1]],"extraConstraint"],Association["extraConstraint"->obj["extraConstraint"]/.((#->0)&/@dpars)],<||>],
			KeyDrop[obj[[1]],{"fitObject","chisqMins","fitResults","fitQualities","extraConstraint","batchType"}]
				]
	]
	]


(* ::Input::Initialization:: *)
penultyCriterion[res_List,dof_,type_String]:=
Switch[type,
"AIC",(2*Length[res]),
"AICc",(2*Length[res])+(2*Length[res]*(Length[res]+1))/(dof-1)
]

Options[modelSelect]={criterion->"AIC",cutOff->4};

modelSelect::usage="Define"
modelSelect[batchobj_?batchFitObjectQ,OptionsPattern[]]:=
Module[{cmin=batchobj["chisqMins"],fres=batchobj["fitResults"],dofl=batchobj["fitQualities"]["dofSimple"],
		aiclst,daicl,saicl,psum},
	aiclst=SortBy[Table[{i,cmin[[i]]+penultyCriterion[fres[[i]],dofl[[i]],OptionValue[criterion]]},
						{i,Length@cmin}],Last];
	psum=Total[E^(-(#[[2]]-aiclst[[1,2]])/2)&/@aiclst];
	daicl=Table[{aiclst[[i,1]],aiclst[[i,2]],aiclst[[i,2]]-aiclst[[1,2]],E^(-(aiclst[[i,2]]-aiclst[[1,2]])/2)/psum},
				{i,Length@aiclst}];
	saicl=Select[daicl,#[[2]]-aiclst[[1,2]]<=OptionValue[cutOff]&];
	Association[{"batchObject"->batchobj,"Criterion"->OptionValue[criterion],
				"Indices"->Evaluate[First/@saicl],"Values"->Evaluate[#[[2]]&/@saicl],"\[CapitalDelta]s"->Evaluate[#[[3]]&/@saicl],
				"\!\(\*SuperscriptBox[\(\[ScriptW]\), \(\[CapitalDelta]s\)]\)"->Evaluate[Last/@saicl]}]
]


(* ::Input::Initialization:: *)
Options[MSEpart]=Options[partFit]~Join~{normalised->True,error->True};

MSEpart::usage="Define"
MSEpart[minobj_?chiSqMinObjectQ,dropdata_List,opts:OptionsPattern[]]:=
Module[{pft=partFit[minobj,dropdata,Evaluate[FilterRules[{opts},Options[partFit]]]][[2]],
		fitobj=minobj["fitObject"],ert=minobj["errorType"],dat,ers,ths,vls,ses},
	dat=Keys[fitobj["observables"]["data"]][[dropdata]];
	ths=If[KeyExistsQ[fitobj["Expand"],"theory"],
			fitobj["theory"]/.pft,
			pft
		];
	vls=Values[#["central"]&/@(fitobj["observables"]["data"])][[dropdata]];
	ers=If[OptionValue[normalised],
			Total[If[ListQ[#],errorFormat[ert,#]^2,#^2]&/@#]&/@(Values[#["uncertainties"]&/@(fitobj["observables"]["data"])][[dropdata]]),
			Table[1,Length[dat]]
		];
     ses=(vls-(dat/.ths))^2/ers;
	If[OptionValue[error],{Mean[ses],StandardDeviation[ses]},Mean[ses]]
]

Options[kFoldXValidation]=Options[MSEpart];

kFoldXValidation::usage="Define"
kFoldXValidation::noint="The supplied value of k=`1` is not a factor of the number of data = `2`"
kFoldXValidation[minobj_?chiSqMinObjectQ,kval_,opts:OptionsPattern[]]:=
Module[{dat=minobj["fitObject"]["observables"]["data"],plen,tstran,drpdtlst,sesm},
	plen=If[IntegerQ[Length[dat]/kval],
			Length[dat]/kval,
			Message[kFoldXValidation::noint,kval,Length[dat]];Abort[]
		];
	tstran[lst_,leng_]:=With[{ran=RandomSample[lst[[2]],leng]},{ran,Complement[lst[[2]], ran]}];
	drpdtlst=Rest[NestList[tstran[#,plen]&,{{},Range[Length[dat]]},kval][[All, 1]]];
	sesm=ParallelMap[MSEpart[minobj,#,Evaluate[FilterRules[{opts},Options[MSEpart]]]]&,drpdtlst,
							DistributedContexts->{"Global`","OptEx`","OptEx`Private`"},Method->"FinestGrained"];
If[ListQ[sesm[[1]]],{Mean[sesm[[All,1]]],StandardDeviation[sesm[[All,1]]]},{Mean[sesm],StandardDeviation[sesm]}]
]


(* ::Input::Initialization:: *)
(*Options[batchMinObject]=Options[chiSqMinObject];

batchMinObject::usage="batchMinObject[fitobj,varkey,varlst]
 takes a fitObject 'fitobj',  as input, creates a \[Chi]^2, minimizes it, obtains the goodness-of-fit depending the OptionValues, and creates an assoObject of a specific type (chiSqMinObject) with all relevant information for the fit,
 which can then be used for parameter estimation."
batchMinObject::nofit="No fit object nor any minimization result is supplied. Evaluation Aborted."
batchMinObject[minobj_?chiSqMinObjectQ,varkey_,varlst_,opts:OptionsPattern[]]:=
Module[{},
	
]*)


Options[NHessian] = {scale->10^-3};

NHessian::usage = "NHessian[f, x] computes a numerical approximation to the Hessian matrix evaluated at f[x]. NHessian takes the option \'scale\',
which can be a scalar or a vector (matching the length of the vector x). The default value is Scale \[Rule] \!\(\*SuperscriptBox[\(10\), \
\(-3\)]\)."
NHessian[f_,x_?(VectorQ[#,NumericQ]&),OptionsPattern[]]:=
Module[{n,h,norm,z,mat,f0},
	n=Length[x];
	h=OptionValue[scale];
	norm=If[VectorQ[h],Outer[Times,2 h,2 h],4 h^2];
	z=If[VectorQ[h],DiagonalMatrix[h],h*IdentityMatrix[n]];
	mat=ConstantArray[0.,{n, n}];
	f0=f[x];
	Do[mat[[i,j]]=If[i==j,
					0.5 (f[x + 2*z[[i]]] - 2*f0 + f[x - 2 * z[[i]]]),
					f[x + z[[i]] + z[[j]]] - f[x + z[[i]] - z[[j]]] - f[x - z[[i]] + z[[j]]] + f[x - z[[i]] - z[[j]]]
			        ],
		{i, n}, {j, i, n}];
	(mat + Transpose[mat])/norm
]
(* credit: mef - see http://mathematica.stackexchange.com/questions/28948/numeric-calculation-of-hessian *)
(* Also, mBayes ....*)

Options[errorMatForm]={matrixType->"Fisher",orderHess->3(* order used by the built-in experimental Mathematica function *),
						numericType->"Mathematica",scaleNH->10^-2.5(* NHessian package fudge parameter *)};

errorMatForm::usage="errorMatForm[minobj]
 Given a chiSqMinObject 'minobj', this calculates the error-matrix corresponding to the fit-parameters, calculated at the best-fit value."
errorMatForm::numeFunc="The \!\(\*SuperscriptBox[\(\[Chi]\), \(2\)]\) is a numeric function. Hessian won't be evaluated. Evaluation aborted."
errorMatForm[minobj_,OptionsPattern[]]:=
Module[{chsq,res,pars,authes,chsqN,Hscale,chi2impt,coc=0,LMat},
	res=minobj["fitResult"];
	pars=Keys[res];
	chsq=Switch[OptionValue[matrixType],
			"ML",
			chiSqFormFit[minobj["fitObject"],errorType->minobj["errorType"],nuisanceterm->False],
			"Fisher",
			chiSqFormFit[minobj["fitObject"],errorType->minobj["errorType"],nuisanceterm->True]
		];
	If[KeyExistsQ[minobj["fitObject"]["Expand"],"numericFunction"],
		Switch[OptionValue[numericType],
			"Mathematica",
			authes=Block[{e=0},{f=Experimental`CreateNumericalFunction[Keys@res,chsq(*[Keys@res]*),
										{},Hessian->{Automatic,"DifferenceOrder"->OptionValue[orderHess]},EvaluationMonitor:>e++];
							f["Hessian"[Values@res]],e}];
			Print[Row[{"Hessian calculated with ",authes[[2]]," evaluations."}]];
			matrixSymmetrize@Inverse[1/2*authes[[1]]],
			"NHessian",
			chsqN=Compile[Evaluate[{#,_Real}&/@(Keys@res)],chsq];
			Hscale=If[Total@Boole[Map[Equal[#,0]&,Values@res]]==0,Abs[Values@res]*OptionValue[scaleNH],10^-3];
			(* in the rare case that a bf value is zero... *)
			chi2impt[vec_]:=(coc++;chsq[vec]);
			LMat=1/2*NHessian[chi2impt,Values@res,scale->Hscale];
			Print[Row[{"NHessian calculated with ",coc," evaluations."}]];
			matrixSymmetrize@Inverse[LMat]
		],
		matrixSymmetrize@errorMat[chsq,pars,res]
	]
]


Options[HesseResult1D]=Options[errorMatForm]~Join~{sigLevel->1,sigdig->2,type->1};

HesseResult1D::usage="HesseResult1D[minobj]
 Given a chiSqMinObject 'minobj', this calculates the error-matrix corresponding to the fit-parameters, this finds the confidence-intervals corresponding to 'conf'
 and displays the results in various ways. The output is a dataObject"
HesseResult1D[minobj_?chiSqMinObjectQ,opts:OptionsPattern[]]:=
Module[{erf=errorInfo[errorMatForm[minobj,Evaluate[FilterRules[{opts},Options[errorMatForm]]]]],cnf=minobj["fitResult"],dtf},
	dtf=Table[{cnf[[i,1]],cnf[[i,2]],erf[[1,i]]},{i,Length[cnf]}];
	assoObject[Association[{"data"->dataForm[dtf],
							"dataList"->Association[Table[cnf[[i,1]]->
												errorDisplay[{cnf[[i,2]],erf[[1,i]]},
															OptionValue[sigdig],
															OptionValue[type]],{i,Length[cnf]}]],
							"correlations"->Evaluate[correlationForm[dtf,#]&/@{ArrayRules@erf[[2]]}],
							"correlationMat"->erf[[2]]}]
	]
]


MakeBoxes[obj:scanObject[data_?ListQ],form:(StandardForm|TraditionalForm)]^:=
Module[{above,below,icn},
	above={
			BoxForm`SummaryItem[{"Length: ",Length[data[[2]]]}],
			BoxForm`SummaryItem[{"Params: ",data[[1,1]]}]
		};
	below={
			BoxForm`SummaryItem[{"Range: ",data[[1,2]]}],
			BoxForm`SummaryItem[{"Points: ",data[[1,3]]}]
		};
	icn=If[Length[data[[2,1]]]===2,
			If[ListQ[data[[2,1,2]]],
				ListLinePlot[Evaluate[{#[[1]],#[[2,1]]}&/@data[[2]]],PlotRange->All,Axes->False,Filling->Bottom,
							ImageSize->{Automatic,3*CurrentValue["FontCapHeight"]/AbsoluteCurrentValue[Magnification]}],
				ListLinePlot[data[[2]],PlotRange->All,Axes->False,Filling->Bottom,
							ImageSize->{Automatic,3*CurrentValue["FontCapHeight"]/AbsoluteCurrentValue[Magnification]}]
			],
			If[Length[data[[2,1]]]===3,
				ListContourPlot[data[[2]],PlotRange->All,Contours->Evaluate[(1-sigmaLevel[#])&/@{1,3}],
								ContourShading->{None,LightBlue,LightRed},
								FrameTicks->None,
								ImageSize->{Automatic,3*CurrentValue["FontCapHeight"]/AbsoluteCurrentValue[Magnification]}],
				None
			]
		];
	If[$VersionNumber>=11.2,
		BoxForm`ArrangeSummaryBox[scanObject,obj,icn,above,below,form,"Interpretable"->Automatic],
		BoxForm`ArrangeSummaryBox[scanObject,obj,icn,above,below,form]
	]
]

scanObject::usage="scanObject[data]
 Is a specially formatted object used by OptEx, representing scanned lists of data - encapsulating either the one dimensional 1-CL plot for some parameter, or a 2-dimensional contour plots depicting the parameter-spaces. 
 Contains a list of two elements, each of which are lists themselves. The first one contains information about the parameter(s), ranges, scan-points etc., and the second one contains actual data depicting parameter spaces.
scanObject[data][property_String]
 represents different forms of output obtained from 'data', depending the value of 'property'."
scanObject::noform="The argument is not formatted correctly. Evaluation aborted."
scanObject[data_?ListQ][property_String]:=
If[Length[data]===2
		(*&&AllTrue[Flatten@Map[NumericQ,data[[2]],{2}],TrueQ]
		&&ArrayDepth[data[[2]]]===2*),
	Switch[property,
		"List",data,
		"CLPlot",CLPlot[data],
		"CLVal",CLVal[data]
	],
	Message[scanObject::noform];Abort[]
]


Options[CLScanProb1D]=Options[NMinimize]~Join~{kernels->All,prompt->True,sigLevel->5,round->10,autoError->True,extraPoint->{}};

CLScanProb1D::usage="CLScanProb1D[minobj,par,scpts]
 creates a 1-dimensional scanObject for the the parameter 'par' occuring in the fit represented by the chiSqMinObject 'minobj', with 'scpts' number of scan points in the range around the best-fit point,
 specified by the OptionValue of the option sigLevel.
CLScanProb1D[minobj,par,scpts,scrng_List]
 does the same thing, in the custom range specified by the list 'scrng'."
CLScanProb1D::numeFunc="Either the \!\(\*SuperscriptBox[\(\[Chi]\), \(2\)]\) is a numeric function, or the option \'autoError\' is False. Please provide explicit range for scan."
CLScanProb1D[minobj_?chiSqMinObjectQ,par_,scpts_,scrng_List:{},opts:OptionsPattern[]]:=
Module[{pts,chsq,vars,contr,min,rngs,erin,opts2,mine},
	min=If[Length[OptionValue[extraPoint]]===0,
			{par/.minobj["fitResult"]},
			OptionValue[extraPoint]
		];
	erin=If[KeyExistsQ[minobj["fitObject"]["Expand"],"numericFunction"]&&!OptionValue[autoError],
			None,
			errorInfo[errorMatForm[minobj]][[1,Position[Keys[minobj["fitResult"]],par][[1,1]]]]
		];
	rngs=If[Length[scrng]===0,
			If[erin===None,
				Message[CLScanProb1D::numeFunc];Abort[],
				Flatten@N@Round[{Subtract@@#,Plus@@#}&@{min,OptionValue[sigLevel]*erin},10^-OptionValue[round]]
			],
			scrng
		];
	mine=If[AllTrue[min,IntervalMemberQ[Interval[rngs],#]&],min,{}];
	pts=Sort[Union[Join[Range[Sequence@@rngs,Abs[Subtract@@rngs]/scpts],mine]]];
	chsq=chiSqFormFit[minobj["fitObject"],nuisanceterm->minobj["keepnuisance"]];
	contr=If[KeyExistsQ[minobj["Expand"],"extraConstraint"],
			{And@@Join[constraintForm[minobj["fitObject"],minobj["errorType"],
											nuisanceterm->minobj["keepnuisance"]],
				minobj["extraConstraint"]]},
			(*constraintForm[minobj["fitObject"],minobj["errorType"],nuisanceterm\[Rule]minobj["keepnuisance"]]*)Nothing
			];
	vars=rangeForm[minobj["fitObject"],minobj["errorType"],nuisanceterm->minobj["keepnuisance"]];
	opts2=If[Length[Evaluate[FilterRules[{opts}, Options[NMinimize]]]]>0,
			Evaluate[FilterRules[{opts}, Options[NMinimize]]],
			minobj["NMinimizeOptions"]
		];
	If[$KernelCount===0,
		CloseKernels[];If[OptionValue[kernels]===All,
							LaunchKernels[],
							LaunchKernels[OptionValue[kernels]]
						]
	];
	If[OptionValue[prompt],
		PrintTemporary["Scanning in progress ... "];
		PrintTemporary["Parallel Processing: True",
						If[$KernelCount===0,
							"",
							"\nParallel Kernels: "<>ToString[$KernelCount]
						]
		];
		PrintTemporary["Elapsed time: ",Dynamic[Clock[{0,Infinity,1}]]," seconds"];
	];
	scanObject[
		{{par,rngs,scpts,If[Length[mine]===0,Null,min]},
			ParallelMap[{Sequence@@#,
						1.0-Quiet[ConfLevel[1,
										((NMinimize[{chsq/.{par->#},Sequence@@contr},
													Evaluate@vars,opts2][[1]])-minobj["chisqMin"])]]}&,
						pts,
						DistributedContexts->{"OptEx`","OptEx`Private`","Global`"}]}
		]
]


Options[CLProbObject]=Options[NMinimize]~Join~{kernels->All,prompt->True,sigLevel->5,round->10,autoError->True}~Join~{scan->True,scanPoints->100,extraPoints->{}};

CLProbObject::usage="CLProbObject[minobj]
 Given a chiSqMinObject 'minobj', this function is a way to estimate the profile-likelihoods of all fit parameters, in batch. This can be run initially as an exploratory tool,
 and obtained results can further be modified/pruned using CLScanProb1D or CLScanFC1D. This returns a specific type of assoObject called CLObject."
CLProbObject::numeFunc="Either the \!\(\*SuperscriptBox[\(\[Chi]\), \(2\)]\) is a numeric function, or the option \'autoError\' is False. Please provide explicit range for scan."
CLProbObject[minobj_?chiSqMinObjectQ,scrng_List:{},opts:OptionsPattern[]]:=
Module[{pts,erin,pars,rngs,vls,tmpsc,tmpcll,scrng2,extpt},
	pars=Keys[minobj["fitResult"]];
	vls=Values[minobj["fitResult"]];
	erin=If[KeyExistsQ[minobj["fitObject"]["Expand"],"numericFunction"]&&OptionValue[autoError]==False,
			None,
			errorInfo[errorMatForm[minobj]]
		];
	scrng2=If[erin===None,
				If[Length[scrng]===Length[pars],scrng,Message[CLProbObject::numeFunc];Abort[]],
				PadRight[scrng,Length[pars],Automatic]
			];
	rngs=Table[If[scrng2[[i]]===Automatic,
				{Subtract@@#,Plus@@#}&@{vls[[i]],OptionValue[sigLevel]*erin[[1,i]]},
				scrng2[[i]]
				],{i,Length[pars]}];
	extpt=If[Length[OptionValue[extraPoints]]===0,Table[{},Length[pars]],OptionValue[extraPoints]];
	tmpsc={};
	If[OptionValue[scan],
		Do[tmpcll=PrintTemporary["Parameter being scanned: ",pars[[i]],
								"\nParallel Kernels: ",$KernelCount,
								"\nElapsed time: ",Dynamic[Clock[{0,Infinity,1}]]," seconds"];
			AppendTo[tmpsc,
				CLScanProb1D[minobj,pars[[i]],
							OptionValue[scanPoints],rngs[[i]],
							prompt->False,extraPoint->extpt[[i]],
							Evaluate[FilterRules[FilterRules[FilterRules[{opts}, Options[CLScanProb1D]],Except[prompt]],Except[extraPoint]]]
					]
				];
			NotebookDelete[tmpcll],
		{i,Length[pars]}]
	];
	assoObject[Association[{"minObject"->minobj,
							"CLtype"->"PROB",
							"paramCL"->Association[Table[pars[[i]]->tmpsc[[i]],{i,Length[pars]}]]}
						]]
]
CLObjectQ::usage="Tests whether an assoobject is of the CLObject type or not."
CLObjectQ[asc_?assoObjectQ]:=KeyExistsQ[asc["Expand"],"paramCL"]


Options[pMC1D]=Join[Options[covMatForm],
					{"Simplify"->False,kernels->All,prompt->True,simulData->False,points->100,process->"PlugIn"},
					Options[NMinimize]];

pMC1D::usage="pMC1D[minobj,par,parval]
 given a chiSqMinObject 'minobj', this calculates the p-value corresponding to the parameter 'par' at the value 'parval', using pseudo-experiments. Thus, this is a list of the p-value and the corresponding uncertainty."
pMC1D[minobj_?chiSqMinObjectQ,par_,parval_,opts:OptionsPattern[]]:=
Module[{fitobj,chsq1,chsq2,chsqprob,opts2,dchsqprob,contr1,contr2,vars,obpt,nuisrep,semc},
	fitobj=minobj["fitObject"];
	contr1=If[KeyExistsQ[minobj["Expand"],"extraConstraint"],
			{And@@Join[constraintForm[fitobj,minobj["errorType"],nuisanceterm->minobj["keepnuisance"]],
				minobj["extraConstraint"]]},
			constraintForm[fitobj,minobj["errorType"],nuisanceterm->minobj["keepnuisance"]]
			];
	contr2=If[KeyExistsQ[minobj["Expand"],"extraConstraint"],
			{minobj["extraConstraint"]},
			{}
			];
	vars=rangeForm[fitobj,nuisanceterm->minobj["keepnuisance"]];
	obpt=If[KeyExistsQ[fitobj["Expand"],"simulData"]&&MatchQ[OptionValue[simulData],False],
			fitobj["simulData"]["Expand"],
			populateData[fitobj["observables"],OptionValue[points],
							Evaluate[FilterRules[{opts},Options[populateData]]]]["Expand"]
		];
	nuisrep=If[minobj["keepnuisance"]&&KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"],
				Switch[OptionValue[process],
						"PlugIn",
						KeyTake[minobj["fitResult"],ToExpression/@Keys[fitobj["parameters"]["nuisanceParams"]["data"]]],
						"FC",
						{}
				],
				{}
			];
	chsq1=chiSqFormFitP[fitobj,nuisanceterm->minobj["keepnuisance"],
						Evaluate[FilterRules[{opts},Options[chiSqFormP]]]]/.{par->parval}/.nuisrep;
	chsq2=chiSqFormFitP[fitobj,nuisanceterm->minobj["keepnuisance"],
						Evaluate[FilterRules[{opts},Options[chiSqFormP]]]]/.nuisrep;
	chsqprob=chiSqFormFit[minobj["fitObject"],nuisanceterm->minobj["keepnuisance"]]/.nuisrep;
	opts2=If[Length[Evaluate[FilterRules[{opts}, Options[NMinimize]]]]>0,
			Evaluate[FilterRules[{opts}, Options[NMinimize]]],
			minobj["NMinimizeOptions"]
		];
	dchsqprob=(NMinimize[{chsqprob/.{par->parval},Sequence@@contr1},Evaluate@vars,opts2][[1]])-
				(*minobj["chisqMin"]*)(NMinimize[{chsqprob,Sequence@@contr1},Evaluate@vars,opts2][[1]]);
	If[$KernelCount===0,
		CloseKernels[];If[OptionValue[kernels]===All,
								LaunchKernels[],
								LaunchKernels[OptionValue[kernels]]
							]
	];
	If[OptionValue[prompt],
		PrintTemporary["Scanning for p-value in progress ... "];
		PrintTemporary["Parallel Processing: True",
						If[$KernelCount===0,
							"",
							"\nParallel Kernels: "<>ToString[$KernelCount]
						]
		];
		PrintTemporary["Elapsed time: ",Dynamic[Clock[{0,Infinity,1}]]," seconds"]
	];
	semc=ParallelMap[((Quiet@NMinimize[{chsq1/.AssociationThread[Array[obAr,Length[fitobj["observables"]["data"]]],
																#],
										Sequence@@contr2},Evaluate@vars,opts2][[1]])-
					(Quiet@NMinimize[{chsq2/.AssociationThread[Array[obAr,Length[fitobj["observables"]["data"]]],
																#],
										Sequence@@contr2},Evaluate@vars,opts2][[1]]))&,
					obpt,
					DistributedContexts->{"OptEx`","OptEx`Private`","Global`"}];
	pValueMC[semc,dchsqprob]
]


Options[CLScanFC1D]=Options[pMC1D]~Join~{sigLevel->4,round->10};

CLScanFC1D::usage="CLScanFC1D[minobj,par,scpts]
 creates a 1-dimensional scanObject for the the parameter 'par' occuring in the fit represented by the chiSqMinObject 'minobj', with 'scpts' number of scan points in the range around the best-fit point,
 specified by the OptionValue of the option sigLevel. This contains the p-values at each scan-point, calculated using the pseudo-experiments. 
CLScanFC1D[minobj,par_,scpts_,scrng_List]
 does the same thing, in the custom range specified by the list 'scrng'."
CLScanFC1D::numeFunc="The \!\(\*SuperscriptBox[\(\[Chi]\), \(2\)]\) is a numeric function. Please provide explicit range for scan."
CLScanFC1D::noBestFit="The range specified for scanning does not contain the best-fit result. Evaluation aborted."
CLScanFC1D[minobj_?chiSqMinObjectQ,par_,scpts_,scrng_List:{},opts:OptionsPattern[]]:=
Module[{pts,chsq,vars,contr,min,rngs,erin,opts2,mine},
	min=par/.minobj["fitResult"];
	erin=If[KeyExistsQ[minobj["fitObject"]["Expand"],"numericFunction"],
			None,
			errorInfo[errorMatForm[minobj]][[1,Position[Keys[minobj["fitResult"]],par][[1,1]]]]
		];
	rngs=If[Length[scrng]===0,
			If[erin===None,
				Message[CLScanFC1D::numeFunc];Abort[],
				N@Round[{Subtract@@#,Plus@@#}&@{min,OptionValue[sigLevel]*erin},10^-OptionValue[round]]
			],
			scrng
		];
	mine=If[IntervalMemberQ[Interval[rngs],min],{min},{}];
	pts=Join[Sort[Union[Range[Sequence@@rngs,Abs[Subtract@@rngs]/scpts],mine]]];
	opts2=Join[Evaluate[FilterRules[{opts},FilterRules[Options[pMC1D],Except[prompt]]]],{prompt->False}];
	If[$KernelCount===0,
		CloseKernels[];If[OptionValue[kernels]===All,
							LaunchKernels[],
							LaunchKernels[OptionValue[kernels]]
						]
	];
	If[OptionValue[prompt],
		PrintTemporary["Scanning in progress ... "];
		PrintTemporary["Parallel Processing: True",
						If[$KernelCount===0,
							"",
							"\nParallel Kernels: "<>ToString[$KernelCount]
						]
		];
		PrintTemporary["Elapsed time: ",Dynamic[Clock[{0,Infinity,1}]]," seconds"];
	];
	scanObject[
		{{par,rngs,scpts,If[Length[mine]===0,Null,min]},
			Map[{Sequence@@#,Module[{temp,val},
								temp=PrintTemporary["Point "<>ToString[Position[pts,#][[1,1]]]];
								val=pMC1D[minobj,par,#,opts2];
								NotebookDelete[temp];val
							]}&,pts]}
		]
]


endPoints::usage="endPoints[scanobj,conf]
 Given a scanObject 'scanobj', representing the 1-dimensional parameter-space for a specific fit parameter and a confidence-level 'conf', this finds the confidence-intervals corresponding to 'conf'."
endPoints::norng1="There seems to be no allowed parameter space at the CL of `1` in the region (`2`, `3`).
					Please Check the scan range."
endPoints::noform="The first object is not a 'scanobject'."
endPoints[scanobj_,conf_]:=
Module[{data1=If[Head[scanobj]===scanObject,
				SortBy[scanobj[[1,2]],First],
				Message[endPoints::noform];Abort[]
			],
		min=Last[scanobj[[1,1]]],data,edpt1,edpt2,bnds,edpt3,invls},
	data=If[ListQ[Last@First[data1]],
			{#[[1]],#[[2,1]]}&/@data1,
			data1
		];
	edpt1=Split[data,Sign[(Last@#1-1+conf)]==Sign[(Last@#2-1+conf)]&];
	edpt2=If[Length[edpt1]>1,
			Flatten[Map[{First[#],Last[#]}&,
						Split[SortBy[data,First],Sign[(Last@#1-1+conf)]==Sign[(Last@#2-1+conf)]&]
					],1],
			Message[endPoints::norng1,conf,Sequence@@scanobj[[1,1,2]]];Abort[]
			];
	bnds={Min[#],Max[#]}&@(First/@edpt2);
	edpt3=Sort@Join[Map[Interpolation[#,InterpolationOrder->1][1-conf]&,
											Partition[Reverse/@(Most@Rest@edpt2),2]
										],bnds];
	invls=Interval/@Partition[edpt3,2,1];
	If[data[[1,2]]>(1-conf),
		invls[[1;;;;2]],
		If[data[[1,2]]<(1-conf),
			invls[[2;;;;2]],
			If[data[[2,2]]>(1-conf),
				invls[[1;;;;2]],
				invls[[2;;;;2]]
			]
		]
	]
]


Options[CLResult1D]={display->1,sigdig->2,type->1};

CLResult1D::usage="CLResult1D[scanobj,conf]
 Given a scanObject 'scanobj', representing the 1-dimensional parameter-space for a specific fit parameter and a confidence-level 'conf', this finds the confidence-intervals corresponding to 'conf'
 and displays the results in various ways."
CLResult1D[scanobj_,conf_,OptionsPattern[]]:=
Module[{main,other,ers,invls,
		min=If[Head[scanobj]===scanObject,
				scanobj[[1,1,4,1]],
				Message[endPoints::noform];Abort[]
			]},
	invls=endPoints[scanobj,conf];
	main=Select[invls,IntervalMemberQ[#,min]&];
	ers={min,#[[2]]-min,min-#[[1]]}&@(main[[1,1]]);
	other=If[Length@Complement[invls,main]===0,
			"",
			StringJoin@@Riffle[Map[("["<>StringJoin@@Riffle[ToString/@N[Round[#,10^sigDigit[ers,OptionValue[sigdig]]]],
															","]<>"]")&,
								(First/@Complement[invls,main])]," \[Union] "]
		];
	Which[OptionValue[display]==1,errorDisplay[ers,OptionValue[sigdig],OptionValue[type]],
		OptionValue[display]==2,StringJoin@@Riffle[Map[("["<>
													StringJoin@@Riffle[Map[ToString,
																			N[Round[#,10^sigDigit[ers,OptionValue[sigdig]]]]],
																				","]<>"]")&,
													(First/@invls)]," \[Union] "]
	]
]


Options[CLPlot1D]=Join[Options[ListLinePlot],Options[CLResult1D],
					{format->"Default",xLabel->"Default",color->Blue,details->True,unit->"",bestFit->True}];

CLPlot1D::usage="CLPlot1D[scanobj]
 Given a scanObject 'scanobj', representing the 1-dimensional parameter-space for a specific fit parameter and a confidence-level 'conf', this plots the '1-CL' plot for the corresponding parameter and formats it in several ways."
CLPlot1D[scanobj_,conflvls_List:{0.955,0.6827},opts:OptionsPattern[]]:=
Module[{xgrli=Append[Table[{1-Sort[conflvls][[i]],Directive[Dashed,Black]},{i,Length[conflvls]}],
					{1,Directive[Black,Thick]}],
		xlbl=If[OptionValue[xLabel]==="Default",ToString[scanobj["List"][[1,1]]],OptionValue[xLabel]],
		epts,ygrli,grli,eplg},
	epts=(First@#)&/@endPoints[scanobj,Sort[conflvls][[1]]];
	ygrli=Join[{#,Directive[Dotted,Thick,Black]}&/@Flatten[epts],
					If[OptionValue[bestFit],{#,Directive[Thick,Black]}&/@Last[scanobj[[1,1]]],{}]];
	grli={ygrli,xgrli};
	eplg=If[OptionValue[details],
			Inset[Style[Column[{xlbl<>
								If[OptionValue[display]===1," = "," \[Element] "]<>
								CLResult1D[scanobj,First@Sort[conflvls],
												Evaluate[FilterRules[{opts},Options[CLResult1D]]]]<>
								OptionValue[unit],
								"at "<>ToString[N@Round[First[Sort[conflvls]]*100,10^-1]]<>"% conf. level"}],
						16,FontFamily->"Times New Roman"],{Last[Sort@scanobj["List"][[2]]][[1]],1.25},{Right,Top}],
			{}
		];
	If[ListQ[scanobj["List"][[2,1,2]]],
		Module[{plt},
			plt=Show[ListLinePlot[Evaluate[{#[[1]],#[[2,1]]}&/@(scanobj["List"][[2]])],PlotRange->{All,{0,1.3}},PlotStyle->None,
						InterpolationOrder->2,Filling->Bottom,FillingStyle->Directive[Lighter[OptionValue[color],0.5],
						Opacity[0.6]],GridLines->grli],
					Plot[1,Evaluate[{x,Sequence@@scanobj[[1,1,2]]}],PlotStyle->Directive[Black],Filling->Top,
						FillingStyle->White],
					Sequence@@(Plot[Evaluate[1-Sort[conflvls][[1]]],Evaluate[{x,Sequence@@#}],PlotStyle->None,Filling->Bottom,
									FillingStyle->Directive[Lighter[OptionValue[color],0.5],Opacity[0.6]]]&/@epts),
					FrameLabel->{xlbl,"1-CL"},Frame->True,Axes->False,
					LabelStyle->Directive[Black,FontFamily->"Times New Roman",FontSize->18],
					FrameTicks->{{Automatic,Evaluate[{1-#,ToString[N@Round[#*100,10^-1]]<>"%"}&/@Sort[conflvls]]},
								{Automatic,None}},
					FrameTicksStyle->Directive[FontSize->16],Epilog->eplg,ImageSize->Large];
			Switch[OptionValue[format],
					"Simple",
					ErrorListPlot[Evaluate[{{#[[1]],#[[2,1]]},ErrorBar[#[[2,2]]]}&/@(scanobj["List"][[2]])],
											PlotRange->{All,{0,1}}],
					"Default",
					plt,
					"Detailed",
					Show[plt,
						ErrorListPlot[Evaluate[{{#[[1]],#[[2,1]]},ErrorBar[#[[2,2]]]}&/@(scanobj["List"][[2]])],
											PlotStyle->OptionValue[color],
											PlotRange->{All,{0,1}}]]
			]
		],
		Switch[OptionValue[format],
				"Simple",
				ListLinePlot[scanobj["List"][[2]],PlotRange->{All,{0,1.3}},Evaluate[FilterRules[{opts},
									Options[ListLinePlot]]]],
				"Default",
				Show[ListLinePlot[scanobj["List"][[2]],PlotRange->{All,{0,1.3}},PlotStyle->None,
						InterpolationOrder->2,Filling->Bottom,FillingStyle->Directive[Lighter[OptionValue[color],0.5],
						Opacity[0.6]],GridLines->grli],
					Plot[1,Evaluate[{x,Sequence@@scanobj[[1,1,2]]}],PlotStyle->Directive[Black],Filling->Top,
						FillingStyle->White],
					Sequence@@(Plot[Evaluate[1-Sort[conflvls][[1]]],Evaluate[{x,Sequence@@#}],PlotStyle->None,Filling->Bottom,
									FillingStyle->Directive[Lighter[OptionValue[color],0.5],Opacity[0.6]]]&/@epts),
					FrameLabel->{xlbl,"1-CL"},Frame->True,Axes->False,
					LabelStyle->Directive[Black,FontFamily->"Times New Roman",FontSize->18],
					FrameTicks->{{Automatic,Evaluate[{1-#,ToString[N@Round[#*100,10^-1]]<>"%"}&/@Sort[conflvls]]},
								{Automatic,None}},
					FrameTicksStyle->Directive[FontSize->16],Epilog->eplg,ImageSize->Large]
		]
	]
]


Options[CLScanProb2D]=Options[CLScanProb1D]~Join~{scanRange->{},sigLevel->5,short->True};

CLScanProb2D::usage="Define"
CLScanProb2D::noobj="The first argument is neither a CLObject nor a chiSqMinObject."
CLScanProb2D::norng="The first argument is a chiSqMinObject, please provide a valid scanRange."
CLScanProb2D::norng1="The 'scanRange' option has a wrong format. It should have a format like:
 {{\!\(\*SubscriptBox[\(xrng\), \(1\)]\),\!\(\*SubscriptBox[\(xrng\), \(2\)]\),\!\(\*SubscriptBox[\(xrng\), \(3\)]\)...},{\!\(\*SubscriptBox[\(yrng\), \(1\)]\),\!\(\*SubscriptBox[\(yrng\), \(2\)]\),\!\(\*SubscriptBox[\(yrng\), \(3\)]\)...}}, where each element has a form: \!\(\*SubscriptBox[\(xrngi\), \(i\)]\) = {\!\(\*SubscriptBox[\(xmini\), \(i\)]\),\!\(\*SubscriptBox[\(xmax\), \(i\)]\)}."
CLScanProb2D[CLobj_,pars_?ListQ,scpts_List:{20,20},opts:OptionsPattern[]]:=
Module[{pts,chsq,vars,contr,cmin,min,rngs,minobj,tpts,opts2,ele1},
	minobj=If[CLObjectQ[CLobj],CLobj["minObject"],If[chiSqMinObjectQ[CLobj],CLobj,Message[CLScanProb2D::noobj];Abort[]]];
	min=pars/.minobj["fitResult"];
	rngs=If[Length[OptionValue[scanRange]]===0&&CLObjectQ[CLobj],
			(First/@endPoints[CLobj["paramCL"][#],sigmaLevel[OptionValue[sigLevel]]])&/@pars,
			If[Length[OptionValue[scanRange]]===0&&chiSqMinObjectQ[CLobj],
				Message[CLScanProb2D::norng];Abort[],
				If[Length[OptionValue[scanRange]]===2&&AllTrue[OptionValue[scanRange],ListQ],
					OptionValue[scanRange],
					Message[CLScanProb2D::norng1];Abort[]
				]
			]
		];
	pts=Tuples[Table[Sort@Flatten[Table[Range[Sequence@@rngs[[i,j]],Abs[Subtract@@rngs[[i,j]]]/scpts[[i]]],{j,Length[rngs[[i]]]}]],{i,Length[pars]}]];
	chsq=chiSqFormFit[minobj["fitObject"],nuisanceterm->minobj["keepnuisance"]];
	contr=If[KeyExistsQ[minobj["Expand"],"extraConstraint"],
			{And[Sequence@@constraintForm[minobj["fitObject"],minobj["errorType"],nuisanceterm->minobj["keepnuisance"]],
				minobj["extraConstraint"]]},
			constraintForm[minobj["fitObject"],minobj["errorType"],nuisanceterm->minobj["keepnuisance"]]
			];
	vars=rangeForm[minobj["fitObject"],minobj["errorType"],nuisanceterm->minobj["keepnuisance"]];
	cmin=minobj["chisqMin"];
	opts2=If[Length[Evaluate[FilterRules[{opts}, Options[NMinimize]]]]>0,
			Evaluate[FilterRules[{opts}, Options[NMinimize]]],
			minobj["NMinimizeOptions"]
		];
	If[$KernelCount===0,
		CloseKernels[];If[OptionValue[kernels]===All,
							LaunchKernels[],
							LaunchKernels[OptionValue[kernels]]
						]
	];
	If[OptionValue[prompt],
		PrintTemporary["Scanning in progress ... "];
		PrintTemporary["Parallel Processing: True",
						If[$KernelCount===0,
							"",
							"\nParallel Kernels: "<>ToString[$KernelCount]
						]
		];
		PrintTemporary["Elapsed time: ",Dynamic[Clock[{0,Infinity,1}]]," seconds"];
	];
	tpts=ParallelMap[{Sequence@@#,
					1.0-Quiet[ConfLevel[2,((NMinimize[{chsq/.AssociationThread[pars,#],Sequence@@contr},
														Evaluate@vars,opts2][[1]])-cmin)],{General::munfl}]}&,
					pts,
					DistributedContexts->{"OptEx`","OptEx`Private`","Global`"}];
	ele1=If[CLObjectQ[CLobj],
			(CLobj["paramCL"][#][[1,1,2]]&/@pars),
			MinMax[Flatten[#]]&/@OptionValue[scanRange]
		];
	scanObject[{{pars,ele1,scpts,min},
				If[OptionValue[short],
					Select[ReplacePart[#,3->(Chop[#[[3]]*100]/100)]&/@tpts,Last[#]=!=0&],
						tpts
				]}]
]


Options[CLPlot2D]=Options[ListContourPlot]~Join~{showBestFit->True,format->"Default",xyLabel->"Default",color->Blue,style->"Default",shading->"Default"};

CLPlot2D::usage="Define"
CLPlot2D[scanobj_,conflvls_List,opts:OptionsPattern[]]:=
Module[{lbls=If[OptionValue[xyLabel]==="Default",ToString/@scanobj["List"][[1,1]],OptionValue[xyLabel]],
		(*normplt,*)csty,cshd},
	(*normplt=ListContourPlot[scanobj["List"][[2]],PlotRange\[Rule]All,Contours\[Rule]Evaluate[(1-#)&/@conflvls],Evaluate[FilterRules[{opts}, Options[ListContourPlot]]]];*)
	csty=If[Length[conflvls]>4,
			OptionValue[color],
			(Directive[#,Thick,Lighter@OptionValue[color]]&/@Reverse[{Dashing[{}],Dashed, Dotted, DotDashed}[[;;Length[conflvls]]]])
		];
	cshd=If[Length[conflvls]>4,
			None,
			{None,Sequence@@(Reverse[(Rest@NestList[Lighter,OptionValue[color],4])[[;;Length[conflvls]]]])}
		];
	Switch[OptionValue[format],
			"Custom",
			Show[ListContourPlot[scanobj["List"][[2]],PlotRange->All,Contours->Evaluate[(1-#)&/@conflvls],Evaluate[FilterRules[{opts}, Options[ListContourPlot]]]],
				If[OptionValue[showBestFit],
					ListPlot[{scanobj["List"][[1,4]]},PlotStyle->Darker@OptionValue[color],PlotMarkers->Style["\[Times]",18]],
					Sequence[]
				],
			FrameLabel->lbls,ImageSize->Large],
			"Default",
			Show[Join[{ListContourPlot[scanobj["List"][[2]],PlotRange->All,Contours->Evaluate[(1-#)&/@conflvls],
					ContourStyle->If[OptionValue[style]==="Default",csty,OptionValue[style]],
					ContourShading->If[OptionValue[shading]==="Default",cshd,OptionValue[shading]]]},
				If[OptionValue[showBestFit],
					{ListPlot[{scanobj["List"][[1,4]]},PlotStyle->Darker@OptionValue[color],PlotMarkers->Style["\[Times]",18]]},
					{}
				]],
				FrameLabel->lbls,Frame->True,Axes->False,LabelStyle->Directive[Black,FontFamily->"Times New Roman",FontSize->18],
				FrameTicksStyle->Directive[FontSize->16],ImageSize->Large]
	]
]


Options[asymmErrSimple]=Options[NMinimize];

asymmErrSimple::usage="Define"
asymmErrSimple::noobj="The argument is not a minObject. Evaluation aborted."
asymmErrSimple::leng="Length of the provided range list is not same as the number of parameters. Please check. Evaluation aborted."
asymmErrSimple[minobj_Association,rnglst_List:{},opts:OptionsPattern[]]:=
If[minobj["objectType"]==="minObject",
	Module[{parobj,chsq,chimin,pars,constrs,rngs},
		parobj=minobj["fitObject"]["parameters"];
		chsq=chiSqFormFit[minobj["fitObject"],errorType->minobj["errorType"],nuisanceterm->minobj["keepnuisance"]];
		chimin=minobj["chisqMin"];
		pars=Keys[minobj["fitResult"]];
		constrs=If[Length[rnglst]===0,
					constraintForm[minobj["fitObject"],minobj["errorType"],nuisanceterm->minobj["keepnuisance"]],
					If[Length[rnglst]===Length[pars],
						{And@@Table[rnglst[[i,1]]<=pars[[i]]<=rnglst[[i,2]],{i,Length@pars}]},
						Message[asymmErrSimple::leng];Abort[]
						]
					];
		rngs=If[Length[rnglst]===0,
				rangeForm[minobj["fitObject"],minobj["errorType"],nuisanceterm->minobj["keepnuisance"]],
				If[Length[rnglst]===Length[pars],
					Table[{pars[[i]],Sequence@@rnglst[[i]]},{i,Length@pars}],
					Message[asymmErrSimple::leng];Abort[]
					]
				];
		{Association[minobj["fitResult"]][#]-
			NMinimize[Evaluate[{#,chsq==(chimin+1),Sequence@@constrs}],rngs,Evaluate[FilterRules[{opts},Options[NMinimize]]]][[1]],
			NMaximize[Evaluate[{#,chsq==(chimin+1),Sequence@@constrs}],rngs,Evaluate[FilterRules[{opts},Options[NMaximize]]]][[1]]-
				Association[minobj["fitResult"]][#]}&/@pars
	],Message[asymmErrSimple::noobj];Abort[]
]


Options[errorProp1]=Options[covMatForm];
errorProp1[funclst_,pars_?assoObjectQ,opts:OptionsPattern[]]:=
Module[{dto,vrl,cvl,covpar,jac,covfunc,erf,fncl},
	dto=pars;
	vrl=ToExpression/@Keys[dto["data"]];
	cvl=Values[Lookup[#,"central"]&/@dto["data"]];
	covpar=covMatForm[dto,Evaluate[FilterRules[{opts},Options[covMatForm]]]];
	fncl=If[VectorQ[funclst],
			funclst,
			If[ListQ[funclst],Message[errorProp::nofnlist];Abort[],{funclst}]
		];
	jac=D[fncl,{vrl}];
	covfunc=(jac.covpar.Transpose[jac])/.AssociationThread[vrl,cvl];
	erf=errorInfo[covfunc];
	If[VectorQ[funclst],
		Association["centralValues"->fncl/.AssociationThread[vrl,cvl],
					"uncertainties"->erf[[1]],
					"correlations"->erf[[2]]
		],
		{funclst/.AssociationThread[vrl,cvl],erf[[1,1]]}
	]
]

errorProp2[funclst_,pars_?ListQ,correlations_:{}]:=
Module[{vrl1,cvl1,erl,crr,covpar1,jac1,covfunc1,erf1,fncl1},
	vrl1=ToExpression[#[[1]]]&/@pars;
	cvl1=#[[2]]&/@pars;
	erl=#[[3]]&/@pars;
	crr=If[Length[correlations]===0,
			IdentityMatrix[Length@erl],
			Normal@correlations
		];
	covpar1=covMatGen[erl,crr];
	fncl1=If[VectorQ[funclst],
			funclst,
			If[ListQ[funclst],Message[errorProp::nofnlist];Abort[],{funclst}]
		];
	jac1=D[fncl1,{vrl1}];
	covfunc1=(jac1.covpar1.Transpose[jac1])/.AssociationThread[vrl1,cvl1];
	erf1=errorInfo[covfunc1];
	If[VectorQ[funclst],
		Association["centralValues"->fncl1/.AssociationThread[vrl1,cvl1],
					"uncertainties"->erf1[[1]],
					"correlations"->erf1[[2]]
		],
		{funclst/.AssociationThread[vrl1,cvl1],erf1[[1,1]]}
	]
]

Options[errorProp3]={kernels->All,prompt->True,numeric->False,points->1000}

errorProp3[funclst_,pars_?ListQ,correlations_:{},points_,OptionsPattern[]]:=
Module[{vrl1,cvl1,erl,crr,covpar1,fncl1,mclst,eval1},
	vrl1=ToExpression[#[[1]]]&/@pars;
	cvl1=#[[2]]&/@pars;
	erl=#[[3]]&/@pars;
	crr=If[Length[correlations]===0,
			IdentityMatrix[Length@erl],
			Normal@correlations
		];
	covpar1=covMatGen[erl,crr];
	fncl1=If[VectorQ[funclst],
			funclst,
			If[ListQ[funclst],Message[errorProp::nofnlist];Abort[],{funclst}]
		];
	If[$KernelCount===0,
		CloseKernels[];If[OptionValue[kernels]===All,
							LaunchKernels[],
							LaunchKernels[OptionValue[kernels]]
						]
	];
	If[OptionValue[prompt],
		PrintTemporary["Points are generating ... "];
		PrintTemporary["Parallel Processing: True",
						If[$KernelCount===0,
							"",
							"\nParallel Kernels: "<>ToString[$KernelCount]
						]
		];
		PrintTemporary["Elapsed time: ",Dynamic[Clock[{0,Infinity,1}]]," seconds"];
	];
	mclst=ParallelMap[(funclst/.AssociationThread[vrl1,#])&,
				RandomVariate[MultinormalDistribution[cvl1,covpar1],points],DistributedContexts->{"Global`","OptEx`","OptEx`Private`"}];
	eval1=If[VectorQ[mclst],
			FindDistributionParameters[mclst,NormalDistribution[\[Mu],\[Sigma]]],
			Module[{arr1=Array[\[Mu],Length[fncl1]],arr2=Array[\[Sigma],{Length[fncl1],Length[fncl1]}],eval2},
				eval2=FindDistributionParameters[mclst,MultinormalDistribution[arr1,arr2]];
				{arr1/.eval2,Sequence@@errorInfo[arr2/.eval2]}
			]
		];
	If[VectorQ[funclst],
		Association["centralValues"->eval1[[1]],
					"uncertainties"->eval1[[2]],
					"correlations"->eval1[[3]],
					"Points"->listObject[mclst]
		],
		Association["centralValues"->\[Mu]/.eval1,
					"uncertainties"->\[Sigma]/.eval1,
					"Points"->listObject[mclst]
		]
	]
]
	
Options[errorProp]=Options[covMatForm]~Join~{kernels->All,prompt->True,numeric->False,points->1000};

errorProp::usage="Define"
errorProp::nolist="The provided argument is neither a dataobject, nor a list in required format."
errorProp::nofnlist="The provided function list is not a vector. Please check."
errorProp[funclst_,pars_,correlations_:{},opts:OptionsPattern[]]:=
If[OptionValue[numeric],
	errorProp3[funclst,pars,correlations,OptionValue[points],Evaluate[FilterRules[{opts},Options[errorProp3]]]],
	If[assoObjectQ[pars],
		errorProp1[funclst,pars,Evaluate[FilterRules[{opts},Options[covMatForm]]]],
		If[ListQ[pars],
			errorProp2[funclst,pars,correlations],
			Message[errorProp::nolist];Abort[]
		]
	]
]


Options[pulls]={normalised->True};

pulls::usage="Define"
pulls[minobj_?chiSqMinObjectQ,opts:OptionsPattern[]]:=
Module[{fitobj=minobj["fitObject"],ert=minobj["errorType"],dat,ths,vls,resids,ers},
	dat=fitobj["observables"]["data"];
	ths=If[KeyExistsQ[fitobj["Expand"],"theory"],
			fitobj["theory"]/.minobj["fitResult"],
			minobj["fitResult"]
		];
	vls=Values[#["central"]&/@dat];
	resids=vls-(Keys[dat]/.ths);
	ers=If[OptionValue[normalised],
			Sqrt[Total[If[ListQ[#],errorFormat[ert,#]^2,#^2]&/@#]]&/@Values[#["uncertainties"]&/@dat],
			Table[1,Length[dat]]
		];
	AssociationThread[Keys[dat],Evaluate[resids/ers]]
]

MSEfit::usage="Define"
MSEfit[minobj_?chiSqMinObjectQ]:=
Module[{fitobj=minobj["fitObject"],ert=minobj["errorType"],dat,ths,vls,resids,lnn,lpp},
	dat=fitobj["observables"]["data"];
	ths=If[KeyExistsQ[fitobj["Expand"],"theory"],
			fitobj["theory"]/.minobj["fitResult"],
			minobj["fitResult"]
		];
	vls=Values[#["central"]&/@dat];
	resids=vls-(Keys[dat]/.ths);
	lnn=Length[fitobj["observables"]["data"]];
	lpp=Length[fitobj["parameters"]["freeParams"]];
	resids.resids/(lnn-lpp)
]

Options[partFit]={NMinimizeOptions->{}};

partFit::usage="Define"
partFit[minobj_?chiSqMinObjectQ,dropdata_List,OptionsPattern[]]:=
Module[{fitobj,kys,fitobjnew,excon,nminopt},
	fitobj=minobj["fitObject"];
	kys=If[KeyExistsQ[fitobj["Expand"],"theory"],
			Select[Keys[fitobj["Expand"]],MemberQ[{"observables","theory"},#]==False&],
			Cases[Keys[fitobj["Expand"]],Except["observables"]]
		];
	excon=If[KeyExistsQ[minobj["Expand"],"extraConstraint"],minobj["extraConstraint"],{}];
	fitobjnew=If[KeyExistsQ[fitobj["Expand"],"theory"],
				assoObject[Association[{"observables"->removeData[fitobj["observables"],dropdata],
										"theory"->Normal@KeyDrop[Association@fitobj["theory"],Keys[fitobj["observables"]["data"]][[dropdata]]],
										Sequence@@((#->fitobj["Expand"][#])&/@kys)}]],
				assoObject[Association[{"observables"->removeData[fitobj["observables"],dropdata],
										Sequence@@((#->fitobj["Expand"][#])&/@kys)}]]
			];
	nminopt=If[Length[OptionValue[NMinimizeOptions]]==0,
				If[KeyExistsQ[minobj["Expand"],"NMinimizeOptions"],minobj["NMinimizeOptions"],{}],
				OptionValue[NMinimizeOptions]
			];
	chiSqMinimForm[fitobjnew,extraConstraint->excon,errorType->minobj["errorType"],nuisanceterm->minobj["keepnuisance"],Sequence@@nminopt](*{fitobjnew,excon,nminopt}*)
]

Options[cookDistance]=Options[partFit];

cookDistance::usage="Define"
cookDistance[minobj_?chiSqMinObjectQ,index_,opts:OptionsPattern[]]:=
Module[{fitobj=minobj["fitObject"],pft,vls,diffs},
	pft=partFit[minobj,{index},Evaluate[FilterRules[{opts},Options[partFit]]]];
	vls=If[KeyExistsQ[fitobj["Expand"],"theory"],
			Values[fitobj["theory"]],
			ToExpression/@Keys[fitobj["observables"]["data"]]
		];
	diffs=(vls/.minobj["fitResult"])-(vls/.pft[[2]]);
	diffs.diffs/(Length[fitobj["parameters"]["freeParams"]]*MSEfit[minobj])
]
cookDistance[minobj_?chiSqMinObjectQ,opts:OptionsPattern[]]:=
Module[{fitobj=minobj["fitObject"],kys},
	kys=Keys[fitobj["observables"]["data"]];
	Association@ParallelTable[kys[[i]]->cookDistance[minobj,i,{opts}],{i,Length@kys},DistributedContexts->{"Global`","OptEx`","OptEx`Private`"},Method->"FinestGrained"]
]
cookCutoff[minobj_?chiSqMinObjectQ]:=
Module[{fitobj=minobj["fitObject"],lnn,lpp},
	lnn=Length[fitobj["observables"]["data"]];
	lpp=Length[fitobj["parameters"]["freeParams"]];
	N@Median@FRatioDistribution[lpp,lnn-lpp]
]


Options[resultForm]={asymmErr->True};

resultForm::usage="Define"
resultForm[resobj_?AssociationQ,opts:OptionsPattern[]]:=
Module[{fres=resobj["fitResult"],fer=resobj["errorInfo"],vls,asy},
	asy=If[KeyExistsQ[resobj,"asymmErr"],resobj["asymmErr"],{}];
	vls=If[Length[fres]>Length[fer[[1]]],
		Module[{pfs=Lookup[resobj["fitObject"]["parameters"]["freeParams"],"expression"]},
			Merge[{KeyTake[Association[fres],pfs],
					AssociationThread[pfs,If[OptionValue[asymmErr]&&Length[asy]>0,asy,fer[[1]]]]},Identity]
			],
		Merge[{Association[fres],AssociationThread[Keys[fres],If[OptionValue[asymmErr]&&Length[asy]>0,asy,fer[[1]]]]},Identity]
		];
	Association[{"values"->vls,"correlation"->fer[[2]]}]
]

Options[resultTable]=Options[resultForm]~Join~{displayType->"Short",errorType->1,showCorr->False}~Join~Options[Grid]

resultTable::usage="Define"
resultTable[resobj_Association,rouexpo_:3,sigdig_:2,opts:OptionsPattern[]]:=
Module[{inf=resultForm[resobj,Evaluate[FilterRules[{opts},Options[resultForm]]]],vinf,vinf2},
	vinf={#[[1]],If[Length[Flatten[Values[inf["values"]][[1]]]]>2,
					errorDisplay[Flatten[#[[2]]],sigdig],
					If[OptionValue[errorType]===1,
						errorDisplay1[#[[2]],sigdig],
						errorDisplay2[#[[2]],sigdig]
						]
					]}&/@KeyValueMap[List,inf["values"]];
	vinf2=Which[OptionValue[displayType]==="Short",
				If[OptionValue[showCorr],
					Table[Join[vinf[[i]],N[Round[#,10^-rouexpo]]&/@(inf["correlation"][[i]])],{i,Length[vinf]}],
					vinf],
				OptionValue[displayType]==="Long",
				If[OptionValue[showCorr],
					Table[Join[{If[i==1,resobj["chisqMin"],SpanFromAbove],
								If[i==1,degsOfreedom[resobj["fitObject"]],SpanFromAbove],
								If[i==1,pValueFit[resobj]*100,SpanFromAbove]},
								vinf[[i]],
								N[Round[#,10^-rouexpo]]&/@(inf["correlation"][[i]])],{i,Length[vinf]}],
					Table[Join[{If[i==1,resobj["chisqMin"],SpanFromAbove],
								If[i==1,degsOfreedom[resobj["fitObject"]],SpanFromAbove],
								If[i==1,pValueFit[resobj]*100,SpanFromAbove]},
								vinf[[i]]],{i,Length[vinf]}]]
				];
	Which[OptionValue[displayType]==="Short",
		If[OptionValue[showCorr],
			Grid[Prepend[vinf2,{"Parameter","Value","Correlation",SpanFromLeft}],
				Evaluate[FilterRules[{opts},Options[Grid]]]],
			Grid[Prepend[vinf2,{"Parameter","Value"}],Evaluate[FilterRules[{opts},Options[Grid]]]]
			],
		OptionValue[displayType]==="Long",
		If[OptionValue[showCorr],
			Grid[Prepend[vinf2,{"\!\(\*SuperscriptBox[\(\[Chi]\), \(2\)]\) Min","d.o.f","p value (%)","Parameter","Value","Correlation",SpanFromLeft}],
				Evaluate[FilterRules[{opts},Options[Grid]]]],
			Grid[Prepend[vinf2,{"\!\(\*SuperscriptBox[\(\[Chi]\), \(2\)]\) Min","d.o.f","p value (%)","Parameter","Value"}],
				Evaluate[FilterRules[{opts},Options[Grid]]]]
			]
	]
]


Options[texTable]={vertical->False,horizontal->False,alignment->"c",interpret->"Print"};

texTable::usage="Define"
texTable[inlist_List,opts:OptionsPattern[]]:=
Module[{width,elems1,elems2,head,end,res,vert=If[OptionValue[vertical]==True,"|",""],hori=If[OptionValue[horizontal]==True,"\\hline\n"," "]},
	width=Max[Length/@inlist];
	head="\\begin{tabular}{"<>vert<>"*{"<>ToString[width]<>"}{"<>OptionValue[alignment]<>vert<>"}}\n"<>hori;
	end="\\end{tabular}\n";
	elems1=((" $"<>#<>"$ ")& /@ ToString /@ TeXForm /@ #)& /@ inlist;
	elems2=StringJoin[Join[Riffle[#," & "],{" \\\\\n"<>hori}]]&/@PadRight[elems1,{Length@inlist,width}," "];
	res=StringReplace[StringJoin[head,Sequence@@elems2,end],"\\backlash"->" "];
	Which[OptionValue[interpret]=="Print",res,
		OptionValue[interpret]=="Copy",CopyToClipboard[res];Print["The table is copied to clipboard!"];res
	]
]


Emerald=RGBColor[0/255,155/255,119/255];
TangerineTango=RGBColor[225/255,82/255,61/255];
Iris=RGBColor[91/255, 94/255, 166/255];

colorPalette={
{RGBColor[0/255,109/255,44/255],RGBColor[49/255,163/255,84/255],RGBColor[116/255,196/255,118/255],RGBColor[186/255,228/255,179/255],RGBColor[237/255,248/255,233/255]},
{RGBColor[61/255,82/255,161/255],RGBColor[58/255,137/255,201/255],RGBColor[119/255,183/255,229/255],RGBColor[180/255,221/255,247/255],RGBColor[230/255,245/255,254/255]},
{RGBColor[179/255,0/255,0/255],RGBColor[227/255,74/255,51/255],RGBColor[252/255,141/255,89/255],RGBColor[253/255,204/255,138/255],RGBColor[254/255,240/255,217/255]},
{RGBColor[129/255,15/255,124/255],RGBColor[136/255,86/255,167/255],RGBColor[140/255,150/255,198/255],RGBColor[179/255,205/255,227/255],RGBColor[237/255,248/255,251/255]},
{RGBColor[37/255,37/255,37/255],RGBColor[99/255,99/255,99/255],RGBColor[150/255,150/255,150/255],RGBColor[204/255,204/255,204/255],RGBColor[247/255,247/255,247/255]}
};
showPalette[index_,size_:60]:=
If[index===0,
	Print/@Table[GraphicsRow[Join[Table[Graphics[{colorPalette[[j,i]],Disk[]},ImageSize->size],{i,1,5}],
								{Graphics[{Transparent,Disk[]},ImageSize->size]}]],{j,Length@colorPalette}];,
	GraphicsRow[Join[Table[Graphics[{colorPalette[[index,i]],Disk[]},ImageSize->size],{i,1,5}],
					{Graphics[{Transparent,Disk[]},ImageSize->size]}]]
]

colorsx[index_,n_]:=Join[colorPalette[[index,;;Abs[n]]],{None}]
(* This code is released under the GPL license. Copyright 2018 by Valerio Marra (valerio.marra@me.com) *)



ellipsn[vals_,covm_,i_,j_,n_,sty_]:=Graphics[{EdgeForm[sty],Transparent,Ellipsoid[vals[[{i,j}]],deltaChiSqVal[sigmaLevel[n],2]*Normal@Symmetrize[covm[[{i,j},{i,j}]]]]}]
(*rect1n[vrng_,sty_]:=Graphics[{EdgeForm[sty],Transparent,Rectangle[{vrng[[1]],0},{vrng[[2]],1/Differences[vrng][[1]]}]}]*)

Options[triPlotPartMVG]={sigmas->3,axesSize->10,aspect->1};

triPlotPartMVG[vals_,covm_,i_,j_,sty_,opts:OptionsPattern[]]:=
Module[{nlev,custTicksX,custTicksY,sty1},
	custTicksX=Table[Automatic,Length@vals];(*custTicksX={{.28,.29,.3},{0,.02,.04,.06},{.79,.8,.81}};*)
	custTicksY=custTicksX[[2;;]];
	nlev=1.1*Sqrt[deltaChiSqVal[sigmaLevel[OptionValue[sigmas]],2]];
	sty1=If[ListQ[sty],Directive@@sty,sty];
	If[i===j,
		Plot[PDF[NormalDistribution[vals[[i]],Sqrt[covm[[i,i]]]],x],{x,vals[[i]]-nlev*Sqrt[covm[[i,i]]],vals[[i]]+nlev*Sqrt[covm[[i,i]]]},
			AspectRatio->OptionValue[aspect],Frame->True,FrameStyle->OptionValue[axesSize],ImageMargins->0,Axes->None,
			PlotStyle->sty1,PlotRange->{{vals[[i]]-nlev*Sqrt[covm[[i,i]]],vals[[i]]+nlev*Sqrt[covm[[i,i]]]},All},
			FrameTicks->{{None,None},{custTicksX[[i]],None}}],
		Show[Table[ellipsn[vals,covm,j,i,n,sty],{n,OptionValue[sigmas]}],
			RotateLabel->True,AspectRatio->OptionValue[aspect],Frame->True,FrameStyle->OptionValue[axesSize],ImageMargins->0,Axes->False,PlotRangePadding->None,
			PlotRange->{{vals[[j]]-nlev*Sqrt[covm[[j,j]]],vals[[j]]+nlev*Sqrt[covm[[j,j]]]},{vals[[i]]-nlev*Sqrt[covm[[i,i]]],vals[[i]]+nlev*Sqrt[covm[[i,i]]]}}]
	]
]

Options[triPlotPartUni]={axesSize->10,aspect->1};

triPlotPartUni[vrnglst_,i_,j_,sty_,opts:OptionsPattern[]]:=
Module[{nlev,custTicksX,custTicksY,sty1},
	custTicksX=Table[Automatic,Length@vrnglst];(*custTicksX={{.28,.29,.3},{0,.02,.04,.06},{.79,.8,.81}};*)
	custTicksY=custTicksX[[2;;]];
	sty1=If[ListQ[sty],Directive@@sty,sty];
	If[i===j,
		Show[Graphics[{EdgeForm[sty1],Transparent,
				Rectangle[{vrnglst[[i,1]],0},{vrnglst[[i,2]],1/Differences[vrnglst[[i]]][[1]]}]}],FrameTicks->{{None,None},{custTicksX[[i]],None}},
			AspectRatio->OptionValue[aspect],PlotRangePadding->None,Frame->True,FrameStyle->OptionValue[axesSize],ImageMargins->0,
			PlotRange->{{vrnglst[[i,1]]-0.2*Abs[vrnglst[[i,1]]],vrnglst[[i,2]]+0.2*Abs[vrnglst[[i,2]]]},{0,2/Differences[vrnglst[[i]]][[1]]}}],
		Show[Graphics[{EdgeForm[sty1],Transparent,
				Rectangle[First/@(vrnglst[[{i,j}]]),Last/@(vrnglst[[{i,j}]])]}],
			AspectRatio->OptionValue[aspect],PlotRangePadding->None,Frame->True,FrameStyle->OptionValue[axesSize],ImageMargins->0,
			PlotRange->{{vrnglst[[{i,j}]][[1,1]]-0.2*Abs[vrnglst[[{i,j}]][[1,1]]],vrnglst[[{i,j}]][[1,2]]+0.2*Abs[vrnglst[[{i,j}]][[1,2]]]},
						{vrnglst[[{i,j}]][[2,1]]-0.2*Abs[vrnglst[[{i,j}]][[2,1]]],vrnglst[[{i,j}]][[2,2]]+0.2*Abs[vrnglst[[{i,j}]][[2,2]]]}}]
	]	
]

Options[triPlotPartMix]={sigmas->3,axesSize->10,aspect->1};

triPlotPartMix[vals_,covm_,unilst_,vrnglst_,i_,j_,sty_,opts:OptionsPattern[]]:=
Module[{nlev,custTicksX,custTicksY,sty1},
	custTicksX=Table[Automatic,Length@vals];(*custTicksX={{.28,.29,.3},{0,.02,.04,.06},{.79,.8,.81}};*)
	custTicksY=custTicksX[[2;;]];
	nlev=1.1*Sqrt[deltaChiSqVal[sigmaLevel[OptionValue[sigmas]],2]];
	sty1=If[ListQ[sty],Directive@@sty,sty];
	If[MemberQ[unilst,i],
		Show[Table[Graphics[{EdgeForm[sty1],Transparent,
				Rectangle[{vrnglst[[i,1]],vals[[j]]-Sqrt[deltaChiSqVal[sigmaLevel[n],1]*covm[[j,j]]]},
							{vrnglst[[i,2]],vals[[j]]+Sqrt[deltaChiSqVal[sigmaLevel[n],1]*covm[[j,j]]]}]}],{n,OptionValue[sigmas]}],
			AspectRatio->OptionValue[aspect],PlotRangePadding->None,Frame->True,FrameStyle->OptionValue[axesSize],ImageMargins->0,RotateLabel->True,
			PlotRange->{{vrnglst[[i,1]]-0.2*Abs[vrnglst[[i,1]]],vrnglst[[i,2]]+0.2*Abs[vrnglst[[i,2]]]},
						{vals[[j]]-nlev*Sqrt[covm[[j,j]]],vals[[j]]+nlev*Sqrt[covm[[j,j]]]}}],
		Show[Table[Graphics[{EdgeForm[sty1],Transparent,
				Rectangle[{vrnglst[[j,1]],vals[[i]]-Sqrt[deltaChiSqVal[sigmaLevel[n],1]*covm[[i,i]]]},
							{vrnglst[[j,2]],vals[[i]]+Sqrt[deltaChiSqVal[sigmaLevel[n],1]*covm[[i,i]]]}]}],{n,OptionValue[sigmas]}],
			AspectRatio->OptionValue[aspect],PlotRangePadding->None,Frame->True,FrameStyle->OptionValue[axesSize],ImageMargins->0,RotateLabel->True,
			PlotRange->{{vrnglst[[j,1]]-0.2*Abs[vrnglst[[j,1]]],vrnglst[[j,2]]+0.2*Abs[vrnglst[[j,2]]]},
						{vals[[i]]-nlev*Sqrt[covm[[i,i]]],vals[[i]]+nlev*Sqrt[covm[[i,i]]]}}]
	]
]

Options[triPlotPart]={sigmas->3,axesSize->10,aspect->1};

triPlotPart::usage="triPlotPart[fitobj] creates the 1 and 2 dimensional PDF plots of the priors for the supplied fitObject - 'fitobj'. 
For now, only nuisance parameters can be used in this way."
triPlotPart::nonuis="The supplied fitObject has no nuisance parameters in it."
triPlotPart[vals_,covm_,unilst_,vrnglst_,i_,j_,sty_,opts:OptionsPattern[]]:=
If[MemberQ[unilst,i]&&MemberQ[unilst,j],
		triPlotPartUni[vrnglst,i,j,sty,Evaluate[FilterRules[{opts},Options[triPlotPartUni]]]],
		If[MemberQ[unilst,i]||MemberQ[unilst,j],
			If[MemberQ[unilst,i],
				triPlotPartMix[vals,covm,unilst,vrnglst,i,Evaluate[j-Length[unilst]],sty,Evaluate[FilterRules[{opts},Options[triPlotPartMix]]]],
				triPlotPartMix[vals,covm,unilst,vrnglst,Evaluate[i-Length[unilst]],j,sty,Evaluate[FilterRules[{opts},Options[triPlotPartMix]]]]
			],
			triPlotPartMVG[vals,covm,Evaluate[i-Length[unilst]],Evaluate[j-Length[unilst]],sty,Evaluate[FilterRules[{opts},Options[triPlotPartMVG]]]]
		]
	]


(* ::Input::Initialization:: *)
impadDef[i_,j_,plx_,pnlx_,ply_,pnly_,pnn_,leng_]:=
If[i==j,
	Which[i==1,{{ply,pnn},{pnlx,pnn}},i==leng,{{pnly,pnn},{plx,pnn}},1<i<leng,{{pnly,pnn},{pnlx,pnn}}],
	Which[i==leng&&j>1,{{pnly,pnn},{plx,pnn}},i==leng&&j==1,{{ply,pnn},{plx,pnn}},i>1&&j==1,{{ply,pnn},{pnlx,pnn}},
		i>j,{{pnly,pnn},{pnlx,pnn}}]
]
imszDef[i_,j_,frs_,plx_,pnlx_,ply_,pnly_,pnn_,leng_]:=
If[i==j,
	Which[i==1,{frs+ply+pnn,frs+pnlx+pnn},i==leng,{frs+pnly+pnn,frs+plx+pnn},
		1<i<leng,{frs+pnly+pnn,frs+pnlx+pnn}],
	Which[i==leng&&j>1,{frs+pnly+pnn,frs+plx+pnn},i==leng&&j==1,{frs+ply+pnn,frs+plx+pnn},
		i>1&&j==1,{frs+ply+pnn,frs+pnlx+pnn},i>j,{frs+pnly+pnn,frs+pnlx+pnn}]
]
frlDef[i_,j_,na_,leng_,plx_]:=
If[i==j,
	Which[i==1,{{na,None},{None,None}},i==leng,{{None,None},{plx[[i]],None}},1<i<leng,{None,None}],
	Which[i==leng&&j>1,{{None,None},{plx[[j]],None}},i==leng&&j==1,{{plx[[i]],None},{plx[[j]],None}},
		i>1&&j==1,{{plx[[i]],None},{None,None}},i>j,{None,None}]
]


Options[triPlot]=Options[triPlotPart]~Join~{labelSize->16,frameSize->180,padlabelx->50,padlabely->62,padnolabelx->25,(* controls x-gap size *)
											padnolabely->25,(* controls y-gap size *)padnonumbers->8};

triPlot::usage="triPlot[fitobj] creates a table of 1 and 2 dimensional PDF plots of the priors for the supplied fitObject - 'fitobj'. 
For now, only nuisance parameters can be used in this way."
triPlot::nonuis="The supplied fitObject has no nuisance parameters in it."
triPlot[pars_,vals_,covm_,unilst_,vrnglst_,sty_,opts:OptionsPattern[]]:=
Module[{pads,parlabelsx,impad,imsz,frl,nada,yvals,xvals},
	nada=Text[Style[" ",FontSize->OptionValue[labelSize]]];
	parlabelsx=Text[Style[#,FontFamily->"Times New Roman",Black,FontSize->OptionValue[labelSize]]]&/@pars;
	impad[i_,j_]:=impadDef[i,j,OptionValue[padlabelx],OptionValue[padnolabelx],OptionValue[padlabely],
								OptionValue[padnolabely],OptionValue[padnonumbers],Length[pars]];
	imsz[i_,j_]:=imszDef[i,j,OptionValue[frameSize],OptionValue[padlabelx],OptionValue[padnolabelx],
								OptionValue[padlabely],OptionValue[padnolabely],OptionValue[padnonumbers],Length[pars]];
	frl[i_,j_]:=frlDef[i,j,nada,Length[pars],parlabelsx];
	Grid[
		ReplacePart[ConstantArray[Null,{Length[pars],Length[pars]}],
				{{i_,i_}:>(Show[triPlotPart[vals,covm,unilst,vrnglst,i,i,sty,Evaluate[FilterRules[{opts},Options[triPlotPart]]]],
								FrameLabel->frl[i,i],ImagePadding->impad[i,i],ImageSize->imsz[i,i]]),
			{i_,j_}/;i>j:>(Show[triPlotPart[vals,covm,unilst,vrnglst,i,j,sty,Evaluate[FilterRules[{opts},Options[triPlotPart]]]],
								FrameLabel->frl[i,j],ImagePadding->impad[i,j],ImageSize->imsz[i,j]])}
		],Spacings->{0,0}]
]


Options[priorBayes]=Options[chiSqForm];

priorBayes::usage="priorBayes[fitobj]
 creates the prior for the supplied fitObject - 'fitobj'"
priorBayes::norange="Parameter `1` has nor range specified. Please provide a valid range"
priorBayes[fitobj_?fitObjectQ,opts:OptionsPattern[]]:=
Module[{frees=fitobj["parameters"]["freeParams"],chsqnuis,prnuis,rnglst,prfree,pri,
		nuis=If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"],fitobj["parameters"]["nuisanceParams"],{}]},
	chsqnuis=If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"],
				chiSqForm[fitobj["parameters"]["nuisanceParams"],{},Evaluate[FilterRules[{opts},Options[chiSqForm]]]]
					(*-Log[(2 \[Pi])^(-Length[nuis["data"]]) Det[covMatForm[nuis,Evaluate[FilterRules[{opts}, Options[covMatForm]]]]]]*),
				0];
	prnuis=E^(-(chsqnuis/2));
	rnglst=Table[If[KeyExistsQ[frees[[i]],"range"],
					Lookup[frees[[i]],"range"],
					Message[priorBayes::norange,frees[Keys[frees][[i]]]];Abort[]
				],{i,Length@frees}];
	prfree=1/(Times@@Flatten[Map[Differences,rnglst]]);
	pri=prfree*prnuis;
	If[OptionValue["Simplify"],Simplify[pri],pri]
]

Options[priorLogDensity]=Options[covMatForm];

priorLogDensity::usage="priorBayes[fitobj]
 creates the prior for the supplied fitObject - 'fitobj'"
priorLogDensity::norange="Parameter `1` has nor range specified. Please provide a valid range"
priorLogDensity[fitobj_?fitObjectQ,opts:OptionsPattern[]]:=
Module[{frees=fitobj["parameters"]["freeParams"],distnuis,distfrees,rnglst,
		nuis=If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"],fitobj["parameters"]["nuisanceParams"],{}]},
	distnuis=If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"],
				LogLikelihood[MultinormalDistribution[Evaluate[ToExpression/@Keys@nuis["data"]],
										Evaluate@covMatForm[nuis,Evaluate[FilterRules[{opts}, Options[covMatForm]]]]
							],Evaluate[{Lookup[#,"central"]&/@Values@nuis["data"]}]],
				0
			];
	rnglst=Table[If[KeyExistsQ[frees[[i]],"range"],
					If[StringQ[Lookup[frees[[i]],"range"]],{$MachineLogZero,-$MachineLogZero},Lookup[frees[[i]],"range"]],
					{$MachineLogZero,-$MachineLogZero}
				],
				{i,Length@frees}];
	distfrees=LogLikelihood[UniformDistribution[rnglst],{Evaluate[ToExpression/@Keys@frees]}];
	distfrees+distnuis
]

Options[chiSqBayes]=Options[chiSqForm];

chiSqBayes::usage="chiSqBayes[fitobj]
 creates a \!\(\*SuperscriptBox[\(\[Chi]\), \(2\)]\) function using the supplied fitObject - 'fitobj', including the \!\(\*SuperscriptBox[\(\[Chi]\), \(2\)]\) due to priors."
chiSqBayes[fitobj_?fitObjectQ,opts:OptionsPattern[]]:=
Module[{dataobj=fitobj["observables"],chsq,chsqpr},
	chsq=If[KeyExistsQ[fitobj["Expand"],"theory"],
			chiSqForm[dataobj,fitobj["theory"],Evaluate[FilterRules[{opts},Options[chiSqForm]]]],
			chiSqForm[dataobj,{},Evaluate[FilterRules[{opts},Options[chiSqForm]]]]
			];
	(*chsqpr=(*-2 Log[priorBayes[fitobj,Evaluate[FilterRules[{opts},Options[priorBayes]]]]]*)
	-2*priorLogDensity[fitobj(*,Evaluate[FilterRules[{opts},Options[priorLogDensity]]]*)];*)
	chsq(*+chsqpr*)
]

Options[modelLogLike]=Options[covMatForm];

modelLogLike::usage="modelLogLike[fitobj]
 creates a \!\(\*SuperscriptBox[\(\[Chi]\), \(2\)]\) function using the supplied fitObject - 'fitobj', including the \!\(\*SuperscriptBox[\(\[Chi]\), \(2\)]\) due to priors."
modelLogLike[fitobj_?fitObjectQ,opts:OptionsPattern[]]:=
Module[{dataobj=fitobj["observables"],chsq,chsqpr},
	If[KeyExistsQ[fitobj["Expand"],"theory"],
			LogLikelihood[MultinormalDistribution[Evaluate[Lookup[#,"central"]&/@Values@dataobj["data"]],
										Evaluate@covMatForm[dataobj,Evaluate[FilterRules[{opts}, Options[covMatForm]]]]
							],
						Evaluate[{Values@fitobj["theory"]}]
			],
			LogLikelihood[MultinormalDistribution[Evaluate[Lookup[#,"central"]&/@Values@dataobj["data"]],
										Evaluate@covMatForm[dataobj,Evaluate[FilterRules[{opts}, Options[covMatForm]]]]
							],
						Evaluate[{ToExpression/@Keys@dataobj["data"]}]
			]
	]
]


Options[PlotPrior2D]=Options[covMatForm]~Join~Options[triPlotPart]~Join~{style->TangerineTango};

PlotPrior2D::usage="PlotPrior2D[fitobj] creates the 1 and 2 dimensional PDF plots of the priors for the supplied fitObject - 'fitobj'. 
For now, only nuisance parameters can be used in this way."
PlotPrior2D::nonuis="The supplied fitObject has no nuisance parameters in it."
PlotPrior2D[fitobj_?fitObjectQ,i_,j_,opts:OptionsPattern[]]:=
Module[{frees=fitobj["parameters"]["freeParams"],
		nuis=If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"],fitobj["parameters"]["nuisanceParams"],{}],
		covm,vals,unilst,vrnglst},
	covm=If[Length[nuis]===0,{},covMatForm[nuis,Evaluate[FilterRules[{opts},Options[covMatForm]]]]];
	vals=If[Length[nuis]===0,{},Values[Lookup[#,"central"]&/@nuis["data"]]];
	unilst=Range[Length@Keys[frees]];
	vrnglst=Lookup[#,"range"]&/@Values[frees];
	triPlotPart[vals,covm,unilst,vrnglst,i,j,OptionValue[style],Evaluate[FilterRules[{opts},Options[triPlotPart]]]]
]

Options[triPlotPrior]=Options[covMatForm]~Join~Options[triPlot]~Join~{style->TangerineTango};

triPlotPrior::usage="triPlotPrior[fitobj] creates a table of 1 and 2 dimensional PDF plots of the priors for the supplied fitObject - 'fitobj'. 
For now, only nuisance parameters can be used in this way."
triPlotPrior::nonuis="The supplied fitObject has no nuisance parameters in it."
triPlotPrior[fitobj_?fitObjectQ,opts:OptionsPattern[]]:=
Module[{frees=fitobj["parameters"]["freeParams"],
		nuis=If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"],fitobj["parameters"]["nuisanceParams"],{}],
		covm,pars,vals,unilst,vrnglst},
	covm=If[Length[nuis]===0,{},covMatForm[nuis,Evaluate[FilterRules[{opts},Options[covMatForm]]]]];
	pars=If[Length[nuis]===0,Keys[frees],Join[Keys[frees],Keys[nuis["data"]]]];
	vals=If[Length[nuis]===0,{},Values[Lookup[#,"central"]&/@nuis["data"]]];
	unilst=Range[Length@Keys[frees]];
	vrnglst=Lookup[#,"range"]&/@Values[frees];
	triPlot[pars,vals,covm,unilst,vrnglst,OptionValue[style],Evaluate[FilterRules[{opts},Options[triPlot]]]]
]


Options[PlotFisher2D] = Join[Join[{sigmas -> 3, axesSize -> 10, aspect -> 1}, Options[errorMatForm]], {style -> {Thick, Dashed, Iris}}]; 
PlotFisher2D::usage = "PlotFisher2D[minobj] creates the 1 and 2 dimensional PDF plots of the fitted likelihood (priors*likelihood) for the supplied chiSqMinObject - 'minobj'."
PlotFisher2D::nonuis = "The supplied fitObject has no nuisance parameters in it."
PlotFisher2D[(minobj_)?chiSqMinObjectQ, i_, j_, opts:OptionsPattern[]] := Module[{res = minobj["fitResult"], covm, vals}, 
   covm = errorMatForm[minobj, Evaluate[FilterRules[{opts}, Options[errorMatForm]]]]; vals = Values[res]; triPlotPartMVG[vals, covm, i, j, OptionValue[style], 
     Evaluate[FilterRules[{opts}, Options[triPlotPartMVG]]]]]

Options[triPlotFisher] = Join[Options[PlotFisher2D], {labelSize -> 16, frameSize -> 180, padlabelx -> 50, padlabely -> 62, padnolabelx -> 25, padnolabely -> 25, 
     padnonumbers -> 8}]; 
triPlotFisher::usage = "triPlotFisher[fitobj] creates a table of 1 and 2 dimensional PDF plots of the priors for the supplied fitObject - 'fitobj'. \nFor now, only nuisance \
parameters can be used in this way."
triPlotFisher::nonuis = "The supplied fitObject has no nuisance parameters in it."
triPlotFisher[(minobj_)?chiSqMinObjectQ, opts:OptionsPattern[]] := Module[{res = minobj["fitResult"], covm, pars, vals, nada, parlabelsx, impad, imsz, frl}, 
   covm = errorMatForm[minobj, Evaluate[FilterRules[{opts}, Options[errorMatForm]]]]; pars = ToString /@ Keys[res]; vals = Values[res]; 
    nada = Text[Style[" ", FontSize -> OptionValue[labelSize]]]; 
    parlabelsx = (Text[Style[#1, FontFamily -> "Times New Roman", Black, FontSize -> OptionValue[labelSize]]] & ) /@ pars; 
    impad[i_, j_] := impadDef[i, j, OptionValue[padlabelx], OptionValue[padnolabelx], OptionValue[padlabely], OptionValue[padnolabely], OptionValue[padnonumbers], 
      Length[pars]]; imsz[i_, j_] := imszDef[i, j, OptionValue[frameSize], OptionValue[padlabelx], OptionValue[padnolabelx], OptionValue[padlabely], OptionValue[padnolabely], 
      OptionValue[padnonumbers], Length[pars]]; frl[i_, j_] := frlDef[i, j, nada, Length[pars], parlabelsx]; 
    Grid[ReplacePart[ConstantArray[Null, {Length[pars], Length[pars]}], 
      {{i_, i_} :> Show[triPlotPartMVG[vals, covm, i, i, OptionValue[style], Evaluate[FilterRules[{opts}, Options[triPlotPartMVG]]]], FrameLabel -> frl[i, i], 
         ImagePadding -> impad[i, i], ImageSize -> imsz[i, i]], {i_, j_} /; i > j :> Show[triPlotPartMVG[vals, covm, i, j, OptionValue[style], 
          Evaluate[FilterRules[{opts}, Options[triPlotPartMVG]]]], FrameLabel -> frl[i, j], ImagePadding -> impad[i, j], ImageSize -> imsz[i, j]]}], Spacings -> {0, 0}]]


(* ::Input::Initialization:: *)
TimeLeft[timesofar_, fractiondone_] := If[fractiondone == 0., 60 * 60 * 24. - 1., timesofar * (1. / fractiondone - 1.)];

(*Clear[TimeProgress];*)
TimeProgress[timesofar_?NumericQ, fractiondone_?NumericQ] :=
	Row[{ProgressIndicator[fractiondone],
		", Time elapsed: " <> DateString[timesofar, {"Hour24", ":", "Minute", ":", "Second"}],
		", Time left: " <>DateString[TimeLeft[timesofar, fractiondone], {"Hour24", ":", "Minute", ":", "Second"}]}];


(* ::Input::Initialization:: *)
Sp[x__List] /; (Equal @@ Length /@ {x}) && Length[{x}]>1:=Transpose[{x}]
(*Gets y[i+1] - y[i]*)

SampleList[dist_,state_List, spreads_List] :=RandomVariate[dist[#[[1]],#[[2]]]]&/@ Transpose[{state, spreads}]


(* ::Input::Initialization:: *)
Clear[MCMCResult];
Format[MCMCResult[list_Association]] := "MCMCResult"[list["BestFitParameters"], "\[LeftSkeleton]" <> ToString[Length[list["ParameterRun"]]] <> "\[RightSkeleton]"]

(this:MCMCResult[list_Association])["ParameterRunPlots", opts___]:=
If[KeyExistsQ[list,"Walkers"],
With[{tab=Transpose[Join@@list["ParameterRun"]],pars=list["Parameters"]},
	Table[ListPlot[tab[[i]],Frame->True,Axes->False,FrameLabel->{"Step",ToString[pars[[i]]]},opts]//Rasterize,{i, Length[pars]}]
],
With[{tab=Transpose[list["ParameterRun"]],pars=list["Parameters"]},
	Table[ListPlot[tab[[i]],Frame->True,Axes->False,FrameLabel->{"Step",ToString[pars[[i]]]},opts]//Rasterize,{i, Length[pars]}]
]
];

(this:MCMCResult[list_Association])["MeanRunPlots", opts___]:=
Module[{tab=Transpose[list["ParameterRun"]],pars=list["Parameters"],lst},
lst=MapIndexed[#1/First[#2]&,Accumulate[#]]&/@tab;
Table[ListLinePlot[lst[[i]],AxesLabel->{"Step",ToString[pars[[i]]]},FrameLabel->{"Step",ToString[pars[[i]]]},PlotRange->All,opts]//Rasterize,{i, Length[pars]}]
];

(this:MCMCResult[list_Association])["ParameterHistograms", opts___]:=
Module[{tab=Transpose[list["ParameterRun"][[list["BurnEnd"] ;; list["NumSteps"]]]],pars=list["Parameters"],func},
func=If[list["NumSteps"]>1*^4,
			SmoothHistogram[#,Filling->Axis,Axes->{True,False},Ticks->{Automatic,None},AxesLabel->{ToString[pars[[i]]],None},opts]&,
			Histogram[#,Ticks->{Automatic,None},Axes->{True,False},AxesLabel -> {ToString[pars[[i]]],None},opts]&
	];
Table[func[tab[[i]]], {i, Length[pars]}]
];

(this:MCMCResult[list_])["ResultForm"] :=
Module[{l1=Evaluate@list["Parameters"],l2=Values@list["BestFitParameters"],l3=Values@list["ParameterErrors"],l4=Quantile[list["ParameterRun"][[list["BurnEnd"];;]],{#,0.5,1-#}&@((1-sigmaLevel[1])/2)],l5=mainHDR[#,sigmaLevel[1],500]&/@Transpose[list["ParameterRun"][[list["BurnEnd"];;]]]},
Column[{
Row[{
Grid[Prepend[Table[{l1[[i]],errorDisplay[{l2[[i]],l3[[i]]}],errorDisplay[{l4[[i,2]],l4[[i,2]]-l4[[i,1]],l4[[i,3]]-l4[[i,2]]}],
				If[StringQ[l5[[i]]],
					l5[[i]],
					errorDisplay[{l5[[i,2]],l5[[i,2]]-l5[[i,1]],l5[[i,3]]-l5[[i,2]]}]
				]},{i,Length@l1}],{Style["Params",Bold],Style["Mean \[PlusMinus] St. Dev.",Bold],Style["Median \[PlusMinus] 1\[Sigma] Qantile",Bold],Style["Mode \[PlusMinus] 1\[Sigma] Cred.Int.",Bold]}],
	Frame->All],"  Correlation : ",list["CorrelationMatrix"]}],"\n",
Row[Riffle[this[{"AverageAcceptance","TimeSpent","NumSteps"}],"; "]]
}]
]

(this:MCMCResult[list_])["CentralTendencyAndDispersion"] :=
Module[{l1=Evaluate@list["Parameters"],l2=Values@list["BestFitParameters"],l3=Values@list["ParameterErrors"],l4=Quantile[list["ParameterRun"][[list["BurnEnd"];;]],{#,0.5,1-#}&@((1-sigmaLevel[1])/2)],l5=mainHDR[#,sigmaLevel[1],500]&/@Transpose[list["ParameterRun"][[list["BurnEnd"];;]]]},
Association[Table[l1[[i]]-> Association[Join[{"Mean"->l2[[i]],"StandardDev"->l3[[i]],"Median"->l4[[i,2]],"1SigmaQuantile"->l4[[i,{1,3}]]},
										If[StringQ[l5[[i]]],{"Mode"->l5[[i]],"HDR"->l5[[i]]},{"Mode"->l5[[i,2]],"HDR"->l5[[i,{1,3}]]}]]],{i,Length@l1}]]
]

(this:MCMCResult[list_Association])["Properties"] := Join[Keys@list, {"MeanRunPlots","ParameterRunPlots", "ParameterHistograms","ResultForm","CentralTendencyAndDispersion"}];
(this:MCMCResult[list_Association])[str_String] :=  list[str];
(this:MCMCResult[list_Association])[{str__String}] := Rule @@@ Sp[{str}, this /@ {str}];


(* ::Input::Initialization:: *)
MCMCResultQ::usage="A test of whether the argument is an 'MCMCResult'."
MCMCResultQ[obj_]:=MatchQ[Head[obj],MCMCResult]


(* ::Input::Initialization:: *)
nestListWithMonitor[f_,init_,n_]:=
Module[{temp,lst,it=1,ti=AbsoluteTime[]},
temp=PrintTemporary[Dynamic[Row[{it, "/", n, "  ",TimeProgress[AbsoluteTime[]-ti,it/n]}]]];
lst=NestList[(it++;f[#])&,init,n];NotebookDelete[temp];
lst
]
(* Used with https://mathematica.stackexchange.com/questions/132003/progress-indicator-for-nestlist *)

mcmccomp[func_,dis_,sprds_,opts_:OptionsPattern[]]:=
Compile[{{st,_Real,1},{spl,_Real},{tpl,_Real}},
Module[{tplN,cand,candpl},
	cand=SampleList[dis,st, sprds];
	candpl=func[cand];
	tplN= Min[0., candpl -spl ];
	If[Log[RandomReal[]]<tplN,{cand,candpl,tplN} ,{st,spl,tplN}]
				],Evaluate[FilterRules[{opts},Options[Compile]]]
]
(* Used with https://mathematica.stackexchange.com/questions/112677/fast-implementation-of-metropolis-hastings-update-with-multiple-sets/112739#112739 *)

ClearAll[apply];
SetAttributes[apply,HoldAll];
apply[f:(_Function|_CompiledFunction),vars:{__Symbol}]:=
Function[arglist,
	Block[vars,vars=arglist;f@@vars]
];
(* Used with https://mathematica.stackexchange.com/questions/5114/using-apply-inside-compile *)


(* ::Input::Initialization:: *)
Options[MCMCFast] = {"BurnFraction"->0.1,"Debug"->False,"ProgressMonitor"->Column[{Row[{"Step", "/", "MaxSteps", "  ",TimeProgress["TimeElapsed", "DoneFraction"]}],"CurrentParameters"}],"ProgressInterval"->10,"Monitor"->True,"Proposal"->"Laplace","Thinning"->0,"CompilationTarget"->"WVM"};

MCMCFast::usage = "MCMCFast[plogexpr, paramspec, numsteps]
Perform MCMC sampling of the supplied probability distribution.
1. plogexpr should be an expression that gives the unnormalized log probability for a particular choice of parameter values.
2. paramspec either gives the results of a previous MCMC run (w/ same plogexpr--just to add on more iterations), or lists the model parameters like so: {{param1, ival1, spread1, domain1}, ...}
a) Each param should be symbolic.
b) ival is the initial parameter value.
c) spread is roughly how far to try to change the parameter each step in the Markov chain. In this routine we select new parameters values based on an exponential distribution of the form Exp[\[CapitalDelta]param/spread]. My Numerical Recipes book advises setting these spreads so that the average candidate acceptance is 10-40%. 
d) Each domain is either Reals or a list of all possible values the parameter can take on (needs to be a uniform grid).
3. numsteps is the number of Markov chain steps to perform."
MCMCFast::nonnumer = "Log probability given supplied model does not evaluate to a number for initial parameters; instead evaluated to: `1`\nAbort!";
MCMCFast::badinp = "Bad input: `1`.";
MCMCFast[plogexpr_,paramspec_,num_Integer,extraConstraint_:{},opts:OptionsPattern[]](*/;TestMCMCInput[paramspec, num]*):=
Module[{params,spreads,stateval,sets,Ns,stateplog,temphist,hist,prevhist,prevnum,dist,
		prevtime,n,t1,t2,burn,mcmcfun,transplog,resume,status,bestfitparams,z,corr,vars,plogfunc,plogfunc1,resultlist, bestfitplot,constr},
	status=PrintTemporary["Initializing..."];
	If[Head[paramspec] === List, (*is user attempting to resume previous mcmc run?*)
	resume = False; (*no*)
	params = paramspec[[All, 1]];
	stateval = paramspec[[All, 2]];
	spreads = paramspec[[All, 3]];
	sets = paramspec[[All, 4]];
	prevhist = {};
	prevnum = 0;
	prevtime = 0;
	,
	resume = True; (*yes*)
	params = "Parameters" /. paramspec[[1]];
	stateval = Last["ParameterRun" /. paramspec[[1]]];
	spreads = "ProposalSpreads" /. paramspec[[1]];
	sets = "ParameterDomains" /. paramspec[[1]];
	prevhist := Drop[Sp["ParameterRun", "ParametersLogPRun", "TransitionLogPRun"] /. paramspec[[1]], -1];
	prevnum = Length[prevhist];
	prevtime = "TimeSpent" /. paramspec[[1]]
];
	n = Length[spreads]; (* # of parameters *)
	Ns = Length /@ sets; (* size of each parameter's domain; 0 for real-valued parameters *)
	NotebookDelete[status];status=PrintTemporary["Evaluating chisq..."];
	constr=Function[Evaluate[params],
					If[Length[extraConstraint]===0,
						True,
						And@@extraConstraint
					]];
	plogfunc1= Compile[Evaluate[{#,_Real}&/@params],
					Evaluate@plogexpr,CompilationOptions->{"InlineExternalDefinitions"->True},
					RuntimeOptions->{"EvaluateSymbolically"->False},
					Parallelization->OptionValue["ParallelCompile"],CompilationTarget->OptionValue["CompilationTarget"]];
	plogfunc=With[{f=apply[Evaluate@plogfunc1,Evaluate@params],c=apply[Evaluate@constr,Evaluate@params]},
				Compile[{{pts,_Real,1}},
						If[And[c@pts,f@pts!=-Infinity],f@pts,$MachineLogZero],CompilationOptions->{"InlineCompiledFunctions"->True},
						RuntimeOptions->{"EvaluateSymbolically"->False},
						Parallelization->OptionValue["ParallelCompile"],CompilationTarget->OptionValue["CompilationTarget"]]
			];
	t1 = t2 = AbsoluteTime[];
	NotebookDelete[status];status=PrintTemporary["Initial step..."];
	If[resume,
		stateplog = Last["ParametersLogPRun" /. paramspec[[1]]];
	,
		stateplog = plogfunc@ stateval;
	];
	If[!NumericQ[stateplog],Message[MCMCFast::nonnumer, stateplog];Abort[]];
	transplog=Min[0, - stateplog];
	dist=Switch[OptionValue["Proposal"],"Normal",NormalDistribution,"Laplace",LaplaceDistribution];
	NotebookDelete[status];status=PrintTemporary["Creating the Core Function..."];
	mcmcfun=Compile[{{st,_Real,1},{spl,_Real},{tpl,_Real}},
				Module[{tplN,cand,candpl},
					cand=SampleList[dist,st, spreads];
					candpl=plogfunc[cand];
					tplN= Min[0., candpl -spl ];
					If[Log[RandomReal[]]<tplN,{cand,candpl,tplN} ,{st,spl,tplN}]
				],CompilationOptions->{"InlineExternalDefinitions"->True},
				RuntimeOptions->{"EvaluateSymbolically"->False},
				CompilationTarget->OptionValue["CompilationTarget"]
			];
	NotebookDelete[status];status=PrintTemporary["Sampling the PDF..."];
	(* hist is complete run history. set initial point. *)
	hist =If[OptionValue["Monitor"],
				If[OptionValue["Thinning"]===0,
				nestListWithMonitor[(mcmcfun@@#)&,{stateval,stateplog,transplog},num],
				nestListWithMonitor[Nest[(mcmcfun@@#)&,#,OptionValue["Thinning"]]&,{stateval,stateplog,transplog},num]
				],
				If[OptionValue["Thinning"]===0,
				NestList[(mcmcfun@@#)&,{stateval,stateplog,transplog},num],
				NestList[Nest[(mcmcfun@@#)&,#,OptionValue["Thinning"]]&,{stateval,stateplog,transplog},num]
				]
			];
	NotebookDelete[status];status=PrintTemporary["Creating MCMC Result..."];
	t2=AbsoluteTime[];
	burn = Ceiling[Min[(num + prevnum)/2, Max[1000, (num + prevnum)*OptionValue["BurnFraction"]]]];
	bestfitparams = Rule @@@ Sp[params, Mean[Join[prevhist, hist][[burn ;; num + prevnum, 1]]] // N];
	NotebookDelete[status];status=PrintTemporary["Computing correlation matrix..."];
	corr = Correlation[Join[prevhist, hist][[All, 1]]];
	NotebookDelete[status];status=PrintTemporary["Done!"];
	resultlist = Association[{
					"BestFitParameters" -> bestfitparams,
					"ParameterErrors" -> Rule @@@ Sp[params, StandardDeviation[Join[prevhist, hist][[burn ;; num + prevnum, 1]]] // N],
					"AverageAcceptance" -> N[Mean[Exp[Join[prevhist, hist][[burn ;; num + prevnum, 3]]]]],
					"TimeSpent" -> (t2 - t1) (*Second*) + prevtime,
					"NumSteps" -> num + prevnum,
					"Parameters" -> params,
					"ProposalSpreads" -> spreads,
					"ParameterDomains" -> sets,
					"BurnFraction" -> OptionValue["BurnFraction"],
					"BurnEnd" -> burn,
					"CorrelationMatrix" -> MatrixForm[corr],
					"ParameterRun" -> Join[prevhist, hist][[All, 1]],
					"ParametersLogPRun" -> Join[prevhist, hist][[All, 2]],
					"TransitionLogPRun" -> Join[prevhist, hist][[All, 3]],
				"LogDensity"->plogfunc
					}];
	MCMCResult[resultlist]
	]


(* ::Input::Initialization:: *)
Options[MCMCFastPT] = {"BurnFraction"->0.1,"Debug"->False,"ProgressMonitor"->Column[{Row[{"Step", "/", "MaxSteps", "  ",TimeProgress["TimeElapsed", "DoneFraction"]}],"CurrentParameters"}],"ProgressInterval"->10,"Monitor"->True,"Proposal"->"Laplace","Thinning"->0,"CompilationTarget"->"WVM"};

MCMCFastPT::usage = "MCMCFast[plogexpr, paramspec, numsteps]
Perform MCMC sampling of the supplied probability distribution.
1. plogexpr should be an expression that gives the unnormalized log probability for a particular choice of parameter values.
2. paramspec either gives the results of a previous MCMC run (w/ same plogexpr--just to add on more iterations), or lists the model parameters like so: {{param1, ival1, spread1, domain1}, ...}
a) Each param should be symbolic.
b) ival is the initial parameter value.
c) spread is roughly how far to try to change the parameter each step in the Markov chain. In this routine we select new parameters values based on an exponential distribution of the form Exp[\[CapitalDelta]param/spread]. My Numerical Recipes book advises setting these spreads so that the average candidate acceptance is 10-40%. 
d) Each domain is either Reals or a list of all possible values the parameter can take on (needs to be a uniform grid).
3. numsteps is the number of Markov chain steps to perform."
MCMCFastPT::nonnumer = "Log probability given supplied model does not evaluate to a number for initial parameters; instead evaluated to: `1`\nAbort!";
MCMCFastPT::badinp = "Bad input: `1`.";
MCMCFastPT[plogexprlst_,paramspec_,oldnum_Integer,extraConstraint_:{},opts:OptionsPattern[]](*/;TestMCMCInput[paramspec, num]*):=
Module[{params,spreads,num,stateval,sets,Ns,stateplog,hist,prevhist,prevnum,dist,constr,
		prevtime,n,t1,t2,burn,mcmcfunlst,transplog,resume,status,bestfitparams,z,corr,vars,plogfunclst,plogfunclst1,resultlist, bestfitplot},
	num=If[OptionValue["Thinning"]===0,oldnum,oldnum*OptionValue["Thinning"]];
	status=PrintTemporary["Initializing..."];
	If[Head[paramspec] === List, (*is user attempting to resume previous mcmc run?*)
	resume = False; (*no*)
	params = paramspec[[All, 1]];
	stateval = paramspec[[All, 2]];
	spreads = paramspec[[All, 3]];
	sets = paramspec[[All, 4]];
	prevhist = {};
	prevnum = 0;
	prevtime = 0;
	,
	resume = True; (*yes*)
	params = "Parameters" /. paramspec[[1]];
	stateval = Last["ParameterRun" /. paramspec[[1]]];
	spreads = "ProposalSpreads" /. paramspec[[1]];
	sets = "ParameterDomains" /. paramspec[[1]];
	prevhist := Drop[Sp["ParameterRun", "ParametersLogPRun", "TransitionLogPRun"] /. paramspec[[1]], -1];
	prevnum = Length[prevhist];
	prevtime = "TimeSpent" /. paramspec[[1]]
];
	n = Length[spreads]; (* # of parameters *)
	Ns = Length /@ sets; (* size of each parameter's domain; 0 for real-valued parameters *)
	NotebookDelete[status];status=PrintTemporary["Evaluating chisq..."];
	constr=Function[Evaluate[params],
					If[Length[extraConstraint]===0,
						True,
						And@@extraConstraint
					]];
	plogfunclst1= Table[Compile[Evaluate[{#,_Real}&/@params],
					plogexprlst[[i]],CompilationOptions->{"InlineExternalDefinitions"->True},
					RuntimeOptions->{"EvaluateSymbolically"->False},
					Parallelization->OptionValue["ParallelCompile"],CompilationTarget->OptionValue["CompilationTarget"]],{i,Length@plogexprlst}];
	plogfunclst=Table[With[{f=apply[plogfunclst1[[i]],Evaluate@params],c=apply[Evaluate@constr,Evaluate@params]},
				Compile[{{pts,_Real,1}},
						If[And[c@pts,f@pts!=-Infinity],f@pts,$MachineLogZero],CompilationOptions->{"InlineCompiledFunctions"->True},
						RuntimeOptions->{"EvaluateSymbolically"->False},
						Parallelization->OptionValue["ParallelCompile"],CompilationTarget->OptionValue["CompilationTarget"]]
			],{i,Length[plogfunclst1]}];
	t1 = t2 = AbsoluteTime[];
	NotebookDelete[status];status=PrintTemporary["Initial step..."];
	If[resume,
		stateplog = Last["ParametersLogPRun" /. paramspec[[1]]];
	,
		stateplog = Last[plogfunclst]@ stateval;
	];
	If[!NumericQ[stateplog],Message[MCMCFast::nonnumer, stateplog];Abort[]];
	transplog=Min[0, - stateplog];
	dist=Switch[OptionValue["Proposal"],"Normal",NormalDistribution,"Laplace",LaplaceDistribution];
	NotebookDelete[status];status=PrintTemporary["Creating the Core Function..."];
	mcmcfunlst=Table[Compile[{{st,_Real,1},{spl,_Real},{tpl,_Real}},
				Module[{tplN,cand,candpl},
					cand=SampleList[dist,st,spreads];
					candpl=plogfunclst[[i]][cand];
					tplN= Min[0., candpl -spl ];
					If[Log[RandomReal[]]<tplN,{cand,candpl,tplN} ,{st,spl,tplN}]
				],CompilationOptions->{"InlineExternalDefinitions"->True},
				RuntimeOptions->{"EvaluateSymbolically"->False},
				(*Parallelization\[Rule]OptionValue["ParallelCompile"],*)CompilationTarget->OptionValue["CompilationTarget"]
			],{i,Length@plogfunclst}];
	(*mcmcfun=mcmccomp[plogfunc,dist,spreads,CompilationOptions\[Rule]{"InlineExternalDefinitions"\[Rule]True},
				RuntimeOptions\[Rule]{"EvaluateSymbolically"\[Rule]False},
				Parallelization\[Rule]OptionValue["ParallelCompile"],CompilationTarget\[Rule]OptionValue["CompilationTarget"]];*)
	NotebookDelete[status];status=PrintTemporary["Sampling the PDF..."];
	(* hist is complete run history. set initial point. *)
	hist =If[OptionValue["Monitor"],
				If[OptionValue["Thinning"]===0,
				nestListWithMonitor[(mcmcfun@@#)&,{stateval,stateplog,transplog},num],
				nestListWithMonitor[Nest[(mcmcfun@@#)&,#,OptionValue["Thinning"]]&,{stateval,stateplog,transplog},num]
				],
				If[OptionValue["Thinning"]===0,
				NestList[(mcmcfun@@#)&,{stateval,stateplog,transplog},num],
				NestList[Nest[(mcmcfun@@#)&,#,OptionValue["Thinning"]]&,{stateval,stateplog,transplog},num]
				]
			];
	NotebookDelete[status];status=PrintTemporary["Creating MCMC Result..."];
	t2=AbsoluteTime[];
	burn = Ceiling[Min[(oldnum + prevnum)/2, Max[1000, (oldnum + prevnum)*OptionValue["BurnFraction"]]]];
	bestfitparams = Rule @@@ Sp[params, Mean[Join[prevhist, hist][[burn ;; oldnum + prevnum, 1]]] // N];
	NotebookDelete[status];status=PrintTemporary["Computing correlation matrix..."];
	corr = Correlation[Join[prevhist, hist][[All, 1]]];
	NotebookDelete[status];status=PrintTemporary["Done!"];
	resultlist = Association[{
					"BestFitParameters" -> bestfitparams,
					"ParameterErrors" -> Rule @@@ Sp[params, StandardDeviation[Join[prevhist, hist][[burn ;; oldnum + prevnum, 1]]] // N],
					"AverageAcceptance" -> N[Mean[Exp[Join[prevhist, hist][[burn ;; oldnum + prevnum, 3]]]]],
					"TimeSpent" -> (t2 - t1) (*Second*) + prevtime,
					"NumSteps" -> oldnum + prevnum,
					"Parameters" -> params,
					"ProposalSpreads" -> spreads,
					"ParameterDomains" -> sets,
					"BurnFraction" -> OptionValue["BurnFraction"],
					"BurnEnd" -> burn,
					"CorrelationMatrix" -> MatrixForm[corr],
					"ParameterRun" -> Join[prevhist, hist][[All, 1]],
					"ParametersLogPRun" -> Join[prevhist, hist][[All, 2]],
					"TransitionLogPRun" -> Join[prevhist, hist][[All, 3]],
				"LogDensity"->Last[plogfunclst]
					}];
	MCMCResult[resultlist]
	]


(* ::Input::Initialization:: *)
numericMatrixQ = Function[MatrixQ[#, NumericQ]];
numericVectorQ = Function[VectorQ[#, NumericQ]];

MapMonitored[f_,args_List]:=
Module[{temp,lst,n=Length[args],it=1,ti=AbsoluteTime[]},
temp=PrintTemporary[Dynamic[Row[{it-1, "/", n, "  ",ProgressIndicator[it/n],
								", Time elapsed: " <> DateString[AbsoluteTime[]-ti, {"Hour24", ":", "Minute", ":", "Second"}],
								", Time left: " <>DateString[TimeLeft[AbsoluteTime[]-ti, it/n], {"Hour24", ":", "Minute", ":", "Second"}]}]]];
lst=Map[(it++;f[#])&,args];NotebookDelete[temp];
lst
]

Options[createMCMCChain] = {(*mcMethod\[Rule]{"AdaptiveMetropolis", "Log"},*)"CovarianceLearnDelay"->20,"InitialCovariance"->1};

createMCMCChain[unnormPostLogPDF_CompiledFunction,startPt_List?numericVectorQ,opts:OptionsPattern[]]:=
With[{dim=Length[startPt]},
	Statistics`MCMC`BuildMarkovChain[(*OptionValue[mcMethod]*){"AdaptiveMetropolis", "Log"}][
	startPt,
	unnormPostLogPDF,
	{Replace[OptionValue["InitialCovariance"],
			{
			n_?NumericQ:>DiagonalMatrix[ConstantArray[n, dim]],
			lst_List?numericVectorQ/;Length[lst]===dim:>DiagonalMatrix[lst],
			Except[mat_List?numericMatrixQ] :> DiagonalMatrix[ConstantArray[1, dim]]
			}],
	Replace[OptionValue["CovarianceLearnDelay"],
			{Except[n_Integer]:>20}]
	},
	Real,Compiled ->Head[unnormPostLogPDF] === CompiledFunction
    ]
]

iterateMCMC = Statistics`MCMC`MarkovChainIterate;

nsMCMC[logDensity_,initialPoint_List,meanEst_List,covEst_List,{numberOfSteps_Integer, extraSteps_Integer, maxSteps_Integer},minMaxAcceptanceRate : (*{_,_}*){0.1,0.9}]:=
 With[{startingIteration=10},
	Module[{(* Initialise the chain at step 10 so that the estimated covariance does not go all over the place *)
			chain = Statistics`MCMC`BuildMarkovChain[{"AdaptiveMetropolis", "Log"}][
					"FullState",{initialPoint, startingIteration, meanEst, covEst},logDensity,
					{covEst, startingIteration},Real,Compiled->Head[logDensity]===CompiledFunction]},
		iterateMCMC[chain, {1, numberOfSteps}];
		While[Nor[TrueQ @ Between[chain["AcceptanceRate"], minMaxAcceptanceRate],
				TrueQ[chain["StateData"][[2]]>=maxSteps + startingIteration]],
			iterateMCMC[chain, {1, extraSteps}]
		];
		Append[AssociationThread[{"Point","MeanEstimate","CovarianceEstimate"},
								chain["StateData"][[{1, 3, 4}]]],
				"AcceptanceRate"->chain["AcceptanceRate"]]
	]
]

Options[generateStartingPoints] =Options[priorLogDensity]~Join~{"BurnInPeriod"->1000,"Thinning" ->1000};

generateStartingPoints[fitobj_?fitObjectQ,initpt_,n_Integer,opts:OptionsPattern[]]:=
Module[{frees=fitobj["parameters"]["freeParams"],chain,
		pdst=priorLogDensity[fitobj,Evaluate[FilterRules[{opts},Options[priorLogDensity]]]],samples,pars},
	pars=ToExpression[Keys[frees]]~Join~If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"],
											ToExpression[Keys[fitobj["parameters"]["nuisanceParams"]["data"]]],
											{}
										];
	chain = With[{crudeSamples=RandomVariate[pdst, 100]},
			Statistics`MCMC`BuildMarkovChain[{"AdaptiveMetropolis", "Log"}][
				First @ crudeSamples,logPDF,
            {DiagonalMatrix[Variance[crudeSamples]], 20},
            Real,
            Compiled -> True
        ]
    ];
    iterateMCMC[chain, {1, OptionValue["BurnInPeriod"]}];
    samples = iterateMCMC[chain, {n, OptionValue["Thinning"]}];
    Print @ StringForm[
        "Generated `1` inital samples using MCMC. Acceptance rate: `2`",
        n,
        chain["AcceptanceRate"]
    ];
    samples
];


(* ::Input::Initialization:: *)
Options[MCMCMath] = Options[createMCMCChain]~Join~{"BurnFraction"->0.1,"Debug"->False,"Monitor"->True,"ProgressMonitor"->Column[{Row[{"Step", "/", "MaxSteps", "  ",TimeProgress["TimeElapsed", "DoneFraction"]}],"CurrentParameters"}],"ProgressInterval"->10,"ParallelCompile"->True,"Thinning"->0,"CompilationTarget"->"WVM"};

MCMCMath::usage = "Define"
MCMCMath::nonnumer = "Log probability of the supplied model does not evaluate to a number for initial parameters; instead evaluated to: `1`\nAbort!";
MCMCMath::badinp = "Bad input: `1`.";
MCMCMath[plogexpr_,paramspec_,num_Integer,extraConstraint_:{},opts:OptionsPattern[]](*/;TestMCMCInput[paramspec, num]*):=
Module[{params,spreads,stateval,sets,Ns,stateplog,chain,hist,burnhist,prevhist,prevnum,
		prevtime,n,t1,t2,burn,(*burniter,*)(*mcmcfun,transplog,*)resume,status,constr,bestfitparams,z,corr,vars,plogfunc,plogfunc1,resultlist, bestfitplot},
	status=PrintTemporary["Initializing..."];
	If[Head[paramspec] === List, (*is user attempting to resume previous mcmc run?*)
	resume = False; (*no*)
	params = paramspec[[All, 1]];
	stateval = paramspec[[All, 2]];
	spreads = paramspec[[All, 3]];
	sets = paramspec[[All, 4]];
	prevhist = {};
	prevnum = 0;
	prevtime = 0;
	,
	resume = True; (*yes*)
	params = "Parameters" /. paramspec[[1]];
	stateval = Last["ParameterRun" /. paramspec[[1]]];
	spreads = "ProposalSpreads" /. paramspec[[1]];
	sets = "ParameterDomains" /. paramspec[[1]];
	prevhist := Drop[Sp["ParameterRun", "ParametersLogPRun", "TransitionLogPRun"] /. paramspec[[1]], -1];
	prevnum = Length[prevhist];
	prevtime = "TimeSpent" /. paramspec[[1]]
];
	n = Length[paramspec]; (* # of parameters *)
	Ns = Length /@ sets; (* size of each parameter's domain; 0 for real-valued parameters *)
	NotebookDelete[status];status=PrintTemporary["Evaluating LogDensity..."];
	constr=Function[Evaluate[params],
					If[Length[extraConstraint]===0,
						True,
						And@@extraConstraint
					]];
	plogfunc1= Compile[Evaluate[{#,_Real}&/@params],
					Evaluate@plogexpr,CompilationOptions->{"InlineExternalDefinitions"->True},
					RuntimeOptions->{"EvaluateSymbolically"->False},
					Parallelization->OptionValue["ParallelCompile"],CompilationTarget->OptionValue["CompilationTarget"]];
	plogfunc=With[{f=apply[Evaluate@plogfunc1,Evaluate@params],c=apply[Evaluate@constr,Evaluate@params]},
				Compile[{{pts,_Real,1}},
						If[And[c@pts,f@pts!=-Infinity],f@pts,$MachineLogZero],CompilationOptions->{"InlineCompiledFunctions"->True},
						RuntimeOptions->{"EvaluateSymbolically"->False},
						Parallelization->OptionValue["ParallelCompile"],CompilationTarget->OptionValue["CompilationTarget"]]
			];
	t1 = AbsoluteTime[];
	NotebookDelete[status];status=PrintTemporary["Initial step..."];
	If[resume,
		stateplog = Last["ParametersLogPRun" /. paramspec[[1]]];
	,
		stateplog = plogfunc@ stateval;
	];
	If[!NumericQ[stateplog],Message[MCMCMath::nonnumer, stateplog];Abort[]];
	(*transplog=Min[0, - stateplog];*)
	NotebookDelete[status];status=PrintTemporary["Creating Markov Chain..."];
	(* hist is complete run history. set initial point. *)
	chain=createMCMCChain[plogfunc,stateval,Evaluate[FilterRules[{opts},Options[createMCMCChain]]]];
	burn = Ceiling[Min[(num (*+ prevnum*))/2, Max[100, (num (*+ prevnum*))*OptionValue["BurnFraction"]]]];
	NotebookDelete[status];status=PrintTemporary[" Sampling the PDF..."];
	hist=Switch[OptionValue["Monitor"],
			True,
			With[{start=AbsoluteTime[]},
				Monitor[If[OptionValue["Thinning"]===0,
						iterateMCMC[chain,num],
						iterateMCMC[chain,{num,OptionValue["Thinning"]}]
					],Row[{ProgressIndicator[Appearance->"Indeterminate"],", Time elapsed: ",
						Dynamic[Refresh[DateString[AbsoluteTime[]-start,{"Hour24", ":", "Minute", ":", "Second"}],
									UpdateInterval->1]]}," "]
				]
			],
			False,
			If[OptionValue["Thinning"]===0,
						iterateMCMC[chain,num],
						iterateMCMC[chain,{num,OptionValue["Thinning"]}]
					](*,
			"Step",
			If[OptionValue["Thinning"]===0,
			Module[{temp,lst={},tls,it=1,ti=AbsoluteTime[]},
				temp=PrintTemporary[Dynamic[Row[{it, "/", num, "  ",ProgressIndicator[it/num],
								", Time elapsed: " <> DateString[AbsoluteTime[]-ti, {"Hour24", ":", "Minute", ":", "Second"}],
								", Time left: " <>DateString[TimeLeft[AbsoluteTime[]-ti, it/num], {"Hour24", ":", "Minute", ":", "Second"}]}]]];
				Do[tls=iterateMCMC[chain,1];
						AppendTo[lst,tls[[1]]];it++,
					{i,num}];NotebookDelete[temp];
				lst
				],
			Module[{temp,lst={},tls,it=1,ti=AbsoluteTime[]},
				temp=PrintTemporary[Dynamic[Row[{it, "/", num, "  ",ProgressIndicator[it/num],
								", Time elapsed: " <> DateString[AbsoluteTime[]-ti, {"Hour24", ":", "Minute", ":", "Second"}],
								", Time left: " <>DateString[TimeLeft[AbsoluteTime[]-ti, it/num], {"Hour24", ":", "Minute", ":", "Second"}]}]]];
				Do[tls=iterateMCMC[chain,{1,OptionValue["Thinning"]}];
						AppendTo[lst,tls[[1]]];it++,
					{i,num}];NotebookDelete[temp];
				lst
				]
			]*)
		];
	NotebookDelete[status];status=PrintTemporary["Creating MCMC Result..."];
	t2=AbsoluteTime[];
	bestfitparams = Rule @@@ Sp[params, Mean[Join[prevhist, hist][[burn ;; num + prevnum]]]//N];
	NotebookDelete[status];status=PrintTemporary["Computing correlation matrix..."];
	corr = Correlation[Join[prevhist,hist][[burn ;; num + prevnum]]];
	NotebookDelete[status];status=PrintTemporary["Creating Results..."];
	resultlist =Association[ {
				"BestFitParameters"->bestfitparams,
				"ParameterErrors"->Rule @@@ Sp[params, StandardDeviation[Join[prevhist,hist][[burn ;; num + prevnum]]] // N],
				"AverageAcceptance"->chain["AcceptanceRate"],
				"TimeSpent"->(t2 - t1) (*Second*) + prevtime,
				"NumSteps"->num + prevnum,
				"Parameters"->params,
				"ProposalSpreads"->{},
				"ParameterDomains"->sets,
				"BurnFraction" -> OptionValue["BurnFraction"],
				"BurnEnd" -> burn,
				"CorrelationMatrix" -> MatrixForm[corr],
				"ParameterRun" -> Join[prevhist,hist],
				"ParametersLogPRun" -> (*plogfunc/@Join[prevhist, hist]*){},
				"TransitionLogPRun" -> {},
				"LogDensity"->plogfunc,
				"Chain"->chain
					}];
	MCMCResult[resultlist](*hist*)
	]


(* ::Input::Initialization:: *)
(*pTabX[q_,nprng_,ngrid_]:=Table[nprng[[q,1]]+(nprng[[q,2]]-nprng[[q,1]]) If[ngrid[[q]]==1,0,(i-1)/(ngrid[[q]]-1)],{i,1,ngrid[[q]]}];*)
multiDims[dims_]:=Rest[Reverse[FoldList[Times,1,Reverse[dims]]]]
next[{left_,_},dim_]:=({left-dim (#1-1),#1}&)[IntegerPart[(left-1)/dim]+1]
multiIndex[pos_,dims:{__Integer}]:=Rest[FoldList[next,{pos,0},multiDims[dims]][[All,2]]]
take[lists:{__List},{start_,end_}]:=With[{rend=Min[end,Times@@Length/@lists]},Transpose[MapThread[Part,{lists,multiIndex[Range[start,rend],Length/@lists]}]]]

Options[chiSqTab]=Join[Options[chiSqBayes],{paramRanges->{},paramGrids->{},division->40,sigmas->5}];

chiSqTab::usage="chiSqTab[fitobj]
 creates a table of \!\(\*SuperscriptBox[\(\[Chi]\), \(2\)]\) values using the supplied fitObject - 'fitobj', including the \!\(\*SuperscriptBox[\(\[Chi]\), \(2\)]\) due to priors."
chiSqTab::leng="Length of supplied paramRanges value does not match with the length of the parameter list: `1`"
chiSqTab[fitobj_?fitObjectQ,opts:OptionsPattern[]]:=
Module[{frees=fitobj["parameters"]["freeParams"],
	nuis=If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"],fitobj["parameters"]["nuisanceParams"],{}],
	dataobj=fitobj["observables"],pars,valnui,covnui,chsq,nuirng,prng,nlev,grds,pspc,pTabX},
pars=ToExpression/@Join[Keys[frees],If[Length[nuis]===0,{},Keys[nuis["data"]]]];
valnui=If[Length[nuis]===0,{},Values[Lookup[#,"central"]&/@nuis["data"]]];
covnui=If[Length[nuis]===0,{},covMatForm[nuis,Evaluate[FilterRules[{opts},Options[covMatForm]]]]];
nlev=If[Length[nuis]===0,0,1.1*Sqrt[deltaChiSqVal[sigmaLevel[OptionValue[sigmas]],2]]];
nuirng=If[Length[nuis]===0,{},
			Table[{valnui[[j]]-nlev*Sqrt[covnui[[j,j]]],valnui[[j]]+nlev*Sqrt[covnui[[j,j]]]},{j,Length[Keys[nuis["data"]]]}]];
prng=If[Length[OptionValue[paramRanges]]===0,
		Join[Lookup[#,"range"]&/@Values[frees],nuirng],
		If[Length[OptionValue[paramRanges]]==Length[pars],OptionValue[paramRanges],Message[chiSqTab::leng,pars];Abort[]]
	];
grds=If[Length[OptionValue[paramGrids]]===0,Table[OptionValue[division],Length@pars],OptionValue[paramGrids]];
pspc=Table[Table[N[prng[[q,1]]+(prng[[q,2]]-prng[[q,1]]) If[grds[[q]]==1,0,(i-1)/(grds[[q]]-1)]],{i,grds[[q]]}],{q,Length@pars}]
(*pTabX[#,prng,grds]&/@Range[Length@pars]*);
chsq=Compile[Evaluate[{#,_Real}&/@pars],Evaluate@chiSqBayes[fitobj,Evaluate[FilterRules[{opts},Options[chiSqBayes]]]]];
(*Times@@grds*)
ParallelTable[chsq[Sequence@@(take[pspc,{i,i}][[1]])],{i,Times@@grds},DistributedContexts->{"Global`","OptEx`","OptEx`Private`"}]
]


(* ::Input::Initialization:: *)
Options[BayesFastFit] = Options[MCMCFast]~Join~Options[chiSqBayes]~Join~{domains->Automatic,extraConstraint->{},likelihoodType->Automatic,sigma->5,division->50,initPoints->Automatic,spread->Automatic};

BayesFastFit::usage = "BayesFastFit[data, errors, model, paramspec, ivars, numsteps]
Perform MCMC samping of the probability distribution resulting from modeling data with model, assuming Gaussian errors. Straightforward wrapper around MCMC and GetChisqExpr.
1. data must be given as: {{ivar1, dvar1}, {ivar2, dvar2}, ..., {ivarN, dvarN}} where ivar is the independent variable, dvar is the dependent variable, and N is the number of data points. Either the ivars or dvars can be vector valued; if the independent variable is a vector, then we're just dealing with a function of multiple variables, and if the dependent variable is, then we have a vector field.
2. errors must have the same length as data (= N), with each entry giving the errors in the corresponding dependent variable supplied in data. If each dvar is just a number, then so too should be each element of errors; if instead each dvar is a vector, then each element of errors should also be a vector of the same length.
3. model should evaluate to either a number or a numerical vector (depending on dvar) when all parameters and independent variables are set.
4. paramspec either gives the results of a previous MCMC run (w/ same plogexpr--just to add on more iterations), or lists the model parameters like so: {{param1, ival1, spread1, domain1}, ...}
a) Each param should be symbolic.
b) ival is the initial parameter value.
c) spread is roughly how far to try to change the parameter each step in the Markov chain. In this routine we select new parameters values based on an exponential distribution of the form Exp[\[CapitalDelta]param/spread]. My Numerical Recipes book advises setting these spreads so that the average candidate acceptance is 10-40%.
d) Each domain is either Reals or a list of all possible values the parameter can take on (needs to be a uniform grid).
5. ivars gives a list of symbolic independent variables, in the same order as in data, on which model depends. If there's only one, then it need not be a list.
6. numsteps is the number of Markov chain steps to perform."
BayesFastFit::norange="Parameter `1` has nor range specified. Please provide a valid range"
BayesFastFit::noobj="Thefirst argument is neither a fitObject, nor a chiSqMinObject."
BayesFastFit[object_,num_Integer,paramspec_:{},opts:OptionsPattern[]]:=
Module[{fitobj=If[chiSqMinObjectQ[object],
			object["fitObject"],
			If[fitObjectQ[object],object,Message[BayesFastFit::noobj];Abort[]]
		],plogexpr,pars,parsp,rnglst,initlst,domlst,nuisrng,sprd,frees,constr},
frees=fitobj["parameters"]["freeParams"];
(*1/2 comes from converting chi^2 to Gaussian*)
plogexpr =Switch[OptionValue[likelihoodType],
Automatic,modelLogLike[fitobj]+priorLogDensity[fitobj],
"Simple",( -chiSqBayes[fitobj,Evaluate[FilterRules[{opts},Options[chiSqBayes]]]] / 2)+priorLogDensity[fitobj]];
rnglst=Table[If[KeyExistsQ[frees[[i]],"range"],
					Lookup[frees[[i]],"range"],
					Message[BayesFastFit::norange,frees[Keys[frees][[i]]]];Abort[]
				],{i,Length@frees}];
pars=ToExpression[Keys[frees]]~Join~
If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"],
	ToExpression[Keys[fitobj["parameters"]["nuisanceParams"]["data"]]],
	{}
];
initlst=If[chiSqMinObjectQ[object],
		Values[object["fitResult"]],
		If[OptionValue[initPoints]===Automatic,
			(RandomReal/@rnglst)~Join~
				If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"],
				(Lookup[#,"central"]&/@Values@fitobj["parameters"]["nuisanceParams"]["data"]),
				{}
				],
			OptionValue[initPoints]
		]
	];
domlst=If[OptionValue[domains]===Automatic,Table[Reals,Length@initlst],OptionValue[domains]];
nuisrng=If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"],
		({Lookup[#,"central"]-(OptionValue[sigma]*Sqrt[Total[Lookup[#,"uncertainties"]^2]]),Lookup[#,"central"]+(OptionValue[sigma]*Sqrt[Total[Lookup[#,"uncertainties"]^2]])})&/@Values@fitobj["parameters"]["nuisanceParams"]["data"],
		{}
	];
sprd=If[OptionValue[spread]===Automatic,
		N[Flatten[Differences/@rnglst]/OptionValue[division]]~Join~If[Length@nuisrng===0,{},N[Flatten[Differences/@nuisrng]/OptionValue[division]]],
		OptionValue[spread]
	];
parsp=If[Length[paramspec]===0&&ListQ[paramspec],
		Table[{pars[[i]],initlst[[i]],sprd[[i]],domlst[[i]]},{i,Length@pars}],
		paramspec
	];
constr=If[chiSqMinObjectQ[object],If[KeyExistsQ[object["Expand"],"extraConstraint"],object["extraConstraint"],{}],OptionValue[extraConstraint]];
Quiet@MCMCFast[plogexpr,parsp,num,constr,Evaluate[FilterRules[{opts},Options[MCMCFast]]]]
]


(* ::Input::Initialization:: *)
Options[BayesFastFitPT] = Options[MCMCFast]~Join~Options[chiSqBayes]~Join~{parallelChains->$ProcessorCount,domains->Automatic,sigma->5,division->50,initPoints->Automatic,spread->Automatic};

BayesFastFitPT::usage = "BayesFastFit[data, errors, model, paramspec, ivars, numsteps]
Perform MCMC samping of the probability distribution resulting from modeling data with model, assuming Gaussian errors. Straightforward wrapper around MCMC and GetChisqExpr.
1. data must be given as: {{ivar1, dvar1}, {ivar2, dvar2}, ..., {ivarN, dvarN}} where ivar is the independent variable, dvar is the dependent variable, and N is the number of data points. Either the ivars or dvars can be vector valued; if the independent variable is a vector, then we're just dealing with a function of multiple variables, and if the dependent variable is, then we have a vector field.
2. errors must have the same length as data (= N), with each entry giving the errors in the corresponding dependent variable supplied in data. If each dvar is just a number, then so too should be each element of errors; if instead each dvar is a vector, then each element of errors should also be a vector of the same length.
3. model should evaluate to either a number or a numerical vector (depending on dvar) when all parameters and independent variables are set.
4. paramspec either gives the results of a previous MCMC run (w/ same plogexpr--just to add on more iterations), or lists the model parameters like so: {{param1, ival1, spread1, domain1}, ...}
a) Each param should be symbolic.
b) ival is the initial parameter value.
c) spread is roughly how far to try to change the parameter each step in the Markov chain. In this routine we select new parameters values based on an exponential distribution of the form Exp[\[CapitalDelta]param/spread]. My Numerical Recipes book advises setting these spreads so that the average candidate acceptance is 10-40%.
d) Each domain is either Reals or a list of all possible values the parameter can take on (needs to be a uniform grid).
5. ivars gives a list of symbolic independent variables, in the same order as in data, on which model depends. If there's only one, then it need not be a list.
6. numsteps is the number of Markov chain steps to perform."
BayesFastFitPT::norange="Parameter `1` has nor range specified. Please provide a valid range"
BayesFastFitPT::procCount="Specified number of chains(`1`) is larger than number of available Processesors(`2`).
Proceeding with `2` parallel chains"
BayesFastFitPT::noobj="Thefirst argument is neither a fitObject, nor a chiSqMinObject."
BayesFastFitPT[object_,num_Integer,paramspec_:{},opts:OptionsPattern[]]:=
Module[{fitobj=If[chiSqMinObjectQ[object],
			object["fitObject"],
			If[fitObjectQ[object],object,Message[BayesFastFit::noobj];Abort[]]
		],llike,plden,chnum,plogexprlst,pars,parsp,rnglst,initlst,domlst,nuisrng,sprd,frees},
frees=fitobj["parameters"]["freeParams"];
(*1/2 comes from converting chi^2 to Gaussian*)
llike=Switch[OptionValue[likelihoodType],
Automatic,modelLogLike[fitobj],"Simple",( -chiSqBayes[fitobj,Evaluate[FilterRules[{opts},Options[chiSqBayes]]]] / 2)];
plden=priorLogDensity[fitobj];
chnum=If[OptionValue[parallelChains]>$ProcessorCount,
Message[BayesFastFit::procCount,OptionValue[parallelChains],$ProcessorCount];$ProcessorCount,
OptionValue[parallelChains]];
plogexprlst=With[{betlst=Drop[Subdivide[chnum],1]},plden+(betlst*llike)];
rnglst=Table[If[KeyExistsQ[frees[[i]],"range"],
					Lookup[frees[[i]],"range"],
					Message[BayesFastFit::norange,frees[Keys[frees][[i]]]];Abort[]
				],{i,Length@frees}];
pars=ToExpression[Keys[frees]]~Join~
If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"],
	ToExpression[Keys[fitobj["parameters"]["nuisanceParams"]["data"]]],
	{}
];
initlst=If[chiSqMinObjectQ[object],
		Values[object["fitResult"]],
		If[OptionValue[initPoints]===Automatic,
			(RandomReal/@rnglst)~Join~
				If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"],
				(Lookup[#,"central"]&/@Values@fitobj["parameters"]["nuisanceParams"]["data"]),
				{}
				],
			OptionValue[initPoints]
		]
	];
domlst=If[OptionValue[domains]===Automatic,Table[Reals,Length@initlst],OptionValue[domains]];
nuisrng=If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"],
		({Lookup[#,"central"]-(OptionValue[sigma]*Sqrt[Total[Lookup[#,"uncertainties"]^2]]),Lookup[#,"central"]+(OptionValue[sigma]*Sqrt[Total[Lookup[#,"uncertainties"]^2]])})&/@Values@fitobj["parameters"]["nuisanceParams"]["data"],
		{}
	];
sprd=If[OptionValue[spread]===Automatic,
		N[Flatten[Differences/@rnglst]/OptionValue[division]]~Join~If[Length@nuisrng===0,{},N[Flatten[Differences/@nuisrng]/OptionValue[division]]],
		OptionValue[spread]
	];
parsp=If[Length[paramspec]===0&&ListQ[paramspec],
		Table[{pars[[i]],initlst[[i]],sprd[[i]],domlst[[i]]},{i,Length@pars}],
		paramspec
	];
Quiet@MCMCFastPT[plogexprlst,parsp,num,Evaluate[FilterRules[{opts},Options[MCMCFastPT]]]]
]


(* ::Input::Initialization:: *)
Options[BayesMathFit] = Options[MCMCMath]~Join~Options[chiSqBayes]~Join~{domains->Automatic,extraConstraint->{},likelihoodType->Automatic,sigma->5,division->50,initPoints->Automatic,spread->Automatic};

BayesMathFit::usage = "Define"
BayesMathFit::norange="Parameter `1` has nor range specified. Please provide a valid range"
BayesMathFit::noobj="Thefirst argument is neither a fitObject, nor a chiSqMinObject."
BayesMathFit[object_,num_Integer,paramspec_:{},opts:OptionsPattern[]]:=
Module[{fitobj=If[chiSqMinObjectQ[object],
			object["fitObject"],
			If[fitObjectQ[object],object,Message[BayesFastFit::noobj];Abort[]]
		],plogexpr,pars,parsp,rnglst,initlst,domlst,nuisrng,sprd,frees,constr},
frees=fitobj["parameters"]["freeParams"];
(*1/2 comes from converting chi^2 to Gaussian*)
plogexpr =Switch[OptionValue[likelihoodType],
Automatic,modelLogLike[fitobj]+priorLogDensity[fitobj],
"Simple",( -chiSqBayes[fitobj,Evaluate[FilterRules[{opts},Options[chiSqBayes]]]] / 2)+priorLogDensity[fitobj]];
rnglst=Table[If[KeyExistsQ[frees[[i]],"range"],
					Lookup[frees[[i]],"range"],
					Message[BayesFastFit::norange,frees[Keys[frees][[i]]]];Abort[]
				],{i,Length@frees}];
pars=ToExpression[Keys[frees]]~Join~
If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"],
	ToExpression[Keys[fitobj["parameters"]["nuisanceParams"]["data"]]],
	{}
];
initlst=If[chiSqMinObjectQ[object],
		If[OptionValue[initPoints]===Automatic,
			Values[object["fitResult"]],
			OptionValue[initPoints]
		],
		If[OptionValue[initPoints]===Automatic,
			(RandomReal/@rnglst)~Join~
				If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"],
				(Lookup[#,"central"]&/@Values@fitobj["parameters"]["nuisanceParams"]["data"]),
				{}
				],
			OptionValue[initPoints]
		]
	];
domlst=If[OptionValue[domains]===Automatic,Table[Reals,Length@initlst],OptionValue[domains]];
nuisrng=If[KeyExistsQ[fitobj["parameters"]["Expand"],"nuisanceParams"],
		({Lookup[#,"central"]-(OptionValue[sigma]*Sqrt[Total[Lookup[#,"uncertainties"]^2]]),Lookup[#,"central"]+(OptionValue[sigma]*Sqrt[Total[Lookup[#,"uncertainties"]^2]])})&/@Values@fitobj["parameters"]["nuisanceParams"]["data"],
		{}
	];
sprd=If[OptionValue[spread]===Automatic,
		N[Flatten[Differences/@rnglst]/OptionValue[division]]~Join~If[Length@nuisrng===0,{},N[Flatten[Differences/@nuisrng]/OptionValue[division]]],
		OptionValue[spread]
	];
parsp=If[Length[paramspec]===0&&ListQ[paramspec],
		Table[{pars[[i]],initlst[[i]],sprd[[i]],domlst[[i]]},{i,Length@pars}],
		paramspec
	];
constr=If[chiSqMinObjectQ[object],If[KeyExistsQ[object["Expand"],"extraConstraint"],object["extraConstraint"],{}],OptionValue[extraConstraint]];
Quiet@MCMCMath[plogexpr,parsp,num,constr,Evaluate[FilterRules[{opts},Options[MCMCMath]]]](*{plogexpr,parsp,num,constr}*)
]


HDReg::usage="HDReg[data,conf]
 Given a dataset, representing the 1-dimensional parameter-space for a specific fit parameter and a credibility-level 'conf', this finds the credibility-intervals corresponding to 'conf'."
HDReg::norng1="There seems to be no allowed parameter space at credibility level `1` in the region (`2`, `3`).
					Please Check the scan range."
HDReg::noform="The first object is not a 'scanobject'."
HDReg[data1D_,cl_,npix_:300]:=
Module[{dist,data,lmts,sigval,edpt1,edpt2,bnds,edpt3,invls},
	lmts=With[{tmpd=(*0.1**)Abs[Subtract@@(MinMax[data1D])]},
			{#[[1]]-tmpd,#[[2]]+tmpd}&@MinMax[data1D]];
	dist=SmoothKernelDistribution[data1D];
	data=ParallelTable[{i,PDF[dist,i]},{i,Range[Sequence@@(lmts),Abs[Subtract@@(lmts)]/npix]}];
	sigval=Ceiling[findCredibilityLevel[Evaluate[Last/@data],{cl}][[1]]];
	edpt1=Split[data,Sign[(Last@#1-sigval)]==Sign[(Last@#2-sigval)]&];
	edpt2=If[Length[edpt1]>1,
			Flatten[Map[{First[#],Last[#]}&,
						Split[data,Sign[(Last@#1-sigval)]==Sign[(Last@#2-sigval)]&]
					],1],
			Message[HDReg::norng1,cl,Sequence@@lmts];Abort[]
			];
	bnds={Min[#],Max[#]}&@(First/@edpt2);
	edpt3=Sort@Join[Map[Interpolation[#,InterpolationOrder->1][sigval]&,
											Partition[Reverse/@(Most@Rest@edpt2),2]
										],bnds];
	invls=Interval/@Partition[edpt3,2,1];
	If[data[[1,2]]>(sigval),
		invls[[1;;;;2]],
		If[data[[1,2]]<(sigval),
			invls[[2;;;;2]],
			If[data[[2,2]]>(sigval),
				invls[[1;;;;2]],
				invls[[2;;;;2]]
			]
		]
	]
]

HDReg2[data1D_,cl_,npix_:300]:=
Module[{dist,data,lmts,sigval,edpt1,edpt2,bnds,edpt3,invls},
	lmts=With[{tmpd=(*0.1**)Abs[Subtract@@(MinMax[data1D])]},
			{#[[1]]-tmpd,#[[2]]+tmpd}&@MinMax[data1D]];
	dist=SmoothKernelDistribution[data1D];
	data=ParallelTable[{i,PDF[dist,i]},{i,Range[Sequence@@(lmts),Abs[Subtract@@(lmts)]/npix]}];
	sigval=Ceiling[findCredibilityLevel[Evaluate[Last/@data],{cl}][[1]]];
	edpt1=Split[data,Sign[(Last@#1-sigval)]==Sign[(Last@#2-sigval)]&];
	If[Length[edpt1]>1,
		edpt2=Flatten[Map[{First[#],Last[#]}&,
							Split[data,Sign[(Last@#1-sigval)]==Sign[(Last@#2-sigval)]&]
						],1];
		bnds={Min[#],Max[#]}&@(First/@edpt2);
		edpt3=Sort@Join[Map[Interpolation[#,InterpolationOrder->1][sigval]&,
												Partition[Reverse/@(Most@Rest@edpt2),2]
											],bnds];
		invls=Interval/@Partition[edpt3,2,1];
		If[data[[1,2]]>(sigval),
			invls[[1;;;;2]],
			If[data[[1,2]]<(sigval),
				invls[[2;;;;2]],
				If[data[[2,2]]>(sigval),
					invls[[1;;;;2]],
					invls[[2;;;;2]]
				]
			]
		],
		"NoRange"
	]
]

mainHDR[data_,conf_,npix_:300]:=
Module[{am=ArgMax[{PDF[SmoothKernelDistribution[data],x],Min[data]<=x<=Max[data]},x],hdr=HDReg2[data,conf,npix]},
	If[StringQ[hdr],
		hdr,
		Insert[Select[hdr,IntervalMemberQ[#,am]&][[1,1]],am,2]
	]
]


(* ::Input::Initialization:: *)
resetBurn[mcres_,newburn_]:=
Module[{unch= {"AverageAcceptance","TimeSpent","NumSteps","Parameters","ProposalSpreads",
			"ParameterDomains","ParameterRun","ParametersLogPRun","TransitionLogPRun","LogDensity","Chain"},ch},
	ch=Association[ {
				"BestFitParameters"->Rule @@@ Sp[mcres["Parameters"], Mean[mcres["ParameterRun"][[newburn ;;]]]//N],
				"ParameterErrors"->Rule @@@ Sp[mcres["Parameters"], StandardDeviation[mcres["ParameterRun"][[newburn  ;;]]] // N],
				"BurnFraction"->N[newburn/mcres["NumSteps"]],
				"BurnEnd"->newburn,
				"CorrelationMatrix"->MatrixForm[Correlation[mcres["ParameterRun"][[newburn ;;]]]]
				}];
	MCMCResult[Join[KeyTake[unch][mcres[[1]]],ch]]
]

Options[saveRun]={fileType->64,"Monitor"->True,"Parallel"->True};

saveRun::usage="Later"
saveRun[mcres_,name_String,OptionsPattern[]]:=
Module[{dirname=FileNameJoin[{NotebookDirectory[],"OptExMCRuns","OptExMC_"<>name}],palpr,plogfunc},
	If[!DirectoryQ[dirname],
		If[!DirectoryQ[FileNameJoin[{NotebookDirectory[],"OptExMCRuns"}]],
			CreateDirectory[FileNameJoin[{NotebookDirectory[],"OptExMCRuns"}]]];
		CreateDirectory[dirname]
	];
	Export[FileNameJoin[{dirname,"RunLog_"<>name<>".m"}],
		Association[Join[mcres[{"BestFitParameters","ParameterErrors","AverageAcceptance","TimeSpent","NumSteps","Parameters",
							"ProposalSpreads","ParameterDomains","BurnFraction","BurnEnd","CorrelationMatrix","LogDensity"}],
					{"fileType"->OptionValue[fileType]}]]];
	Do[Export[FileNameJoin[{dirname,"ParamRun_"<>name<>"_"<>ToString[i]<>".r"<>ToString[OptionValue[fileType]]}],
		ToPackedArray[#[[i]]&/@mcres["ParameterRun"]],"Real"<>ToString[OptionValue[fileType]]],{i,Length[mcres["Parameters"]]}];
	plogfunc=If[Length[mcres["ParametersLogPRun"]]===0,mcres["LogDensity"],{}];
	palpr=If[Length[mcres["ParametersLogPRun"]]===0,
			PrintTemporary["Creating ParametersLogPRun..."];
			If[OptionValue["Monitor"],
				MapMonitored[plogfunc,mcres["ParameterRun"]],
				If[OptionValue["Parallel"],
					ParallelMap[plogfunc,mcres["ParameterRun"],DistributedContexts->{"Global`","OptEx`","OptEx`Private`"}],
					Map[plogfunc,mcres["ParameterRun"]]
				]
			],
			mcres["ParametersLogPRun"]
		];
	Export[FileNameJoin[{dirname,"ParamLogPRun_"<>name<>".r"<>ToString[OptionValue[fileType]]}],ToPackedArray[palpr],
		"Real"<>ToString[OptionValue[fileType]]];
	Export[FileNameJoin[{dirname,"TransLogPRun_"<>name<>".r"<>ToString[OptionValue[fileType]]}],ToPackedArray[mcres["TransitionLogPRun"]],
		"Real"<>ToString[OptionValue[fileType]]];
]

loadRun::usage="Later"
loadRun::norun="The run `1` does not exist. Please run it first."
loadRun::nolog="The run log `1` does not exist. Please run it first."
loadRun[name_String,OptionsPattern[]]:=
Module[{dirname=FileNameJoin[{NotebookDirectory[],"OptExMCRuns","OptExMC_"<>name}],
		log,prtab,lpr,tlpr},
	If[!DirectoryQ[dirname],
		Message[loadRun::norun,name];Abort[],
		If[!FileExistsQ[FileNameJoin[{dirname,"RunLog_"<>name<>".m"}]],
			Message[loadRun::nolog,"RunLog_"<>name<>".m"];Abort[]
		]
	];
	log=Import[FileNameJoin[{dirname,"RunLog_"<>name<>".m"}]];
	prtab=Transpose[Table[Import[FileNameJoin[{dirname,"ParamRun_"<>name<>"_"<>ToString[i]<>".r"<>ToString[log["fileType"]]}],
							"Real"<>ToString[log["fileType"]]],
						{i,Length[log["Parameters"]]}]];
	lpr=Import[FileNameJoin[{dirname,"ParamLogPRun_"<>name<>".r"<>ToString[log["fileType"]]}],"Real"<>ToString[log["fileType"]]];
	tlpr=Import[FileNameJoin[{dirname,"TransLogPRun_"<>name<>".r"<>ToString[log["fileType"]]}],"Real"<>ToString[log["fileType"]]];
	MCMCResult[Join[KeyDrop[log,"fileType"],Association["ParameterRun"->prtab,"ParametersLogPRun"->lpr,"TransitionLogPRun"->tlpr]]]
]


(* ::Input::Initialization:: *)
Options[Posterior1D]={color->Blue,xLabel->"Default",type->"Detailed",details->True,detailType->"Mode",unit->"",position->{0.97,0.97}};

Posterior1D::usage="Later"
Posterior1D[mcres_,parind_Integer,OptionsPattern[]]:=
Module[{dat=Transpose[mcres["ParameterRun"][[mcres["BurnEnd"];;]]][[parind]],mo,qs,val,lab,tip,eplg,smh,his},
mo=If[OptionValue[detailType]==="Mode",mainHDR[#,sigmaLevel[1],500]&@dat];
val=Switch[OptionValue[detailType],
			"Median",Median[dat],
			"Mean",Values[mcres["BestFitParameters"]][[parind]],
			"Mode",mo[[2]]
];
qs=Switch[OptionValue[detailType],
		"Median",Quantile[dat,{#,1-#}&@((1-sigmaLevel[1])/2)],
		"Mean",{val-#,val+#}&@Values[mcres["ParameterErrors"]][[parind]],
		"Mode",mo[[{1,3}]]
];
lab=If[OptionValue[xLabel]==="Default",ToString[mcres["Parameters"][[parind]]],OptionValue[xLabel]];
tip=errorDisplay[{val,Sequence@@(Abs[val-#]&/@qs)}(*,sigdig_:2,type_:1*)];
eplg=Inset[Style[Column[{lab<>" = "<>tip<>OptionValue[unit]}],20,FontFamily->"Times New Roman"],Scaled[OptionValue[position]],{Right,Top}];
his=Histogram[dat,Automatic,"PDF",ChartStyle->Directive[EdgeForm[None],OptionValue[color],Opacity[0.2]]];
smh=Switch[OptionValue[type],
	"Detailed",
	Show[SmoothHistogram[dat,"Oversmooth","PDF",PlotStyle->Directive[OptionValue[color]],Filling->None,
					Axes->False,PlotRange->All],
			SmoothHistogram[dat,"Oversmooth","PDF",PlotStyle->Directive[OptionValue[color],Opacity[0.1],Dashed],Filling->Axis,
					Axes->False,FillingStyle->Directive[OptionValue[color],Opacity[0.1]],PlotRange->{qs,All}],his,
			Frame->True,FrameTicks->{Automatic,None},PlotRangePadding->{None,{None,Scaled[0.1]}},FrameStyle->Directive[Black],
			FrameTicksStyle->Directive[Black,FontFamily->"Times",FontSize->22],
			FrameLabel->Evaluate[Style[#,Black,FontFamily->"Times",FontSize->26]&/@{lab,"PDF"}],GridLines->{qs,None},
			GridLinesStyle->Directive[Gray,Dotted],ImageSize->Large],
	"Simple",
	SmoothHistogram[dat,"Oversmooth","PDF",PlotStyle->Directive[OptionValue[color]],Filling->None,
					Axes->False,PlotRange->All]
	];
If[OptionValue[details],
	Show[smh,Epilog->eplg],
	smh
]
]

Posterior1D[dat_List,lab_String,OptionsPattern[]]:=
Module[{qs},
qs={#[[1]],#[[3]]}&@Quartiles[dat];
Show[SmoothHistogram[dat,"Oversmooth","PDF",PlotStyle->Directive[OptionValue[color]],Filling->Axis,FillingStyle->Directive[OptionValue[color],Opacity[0.1]],PlotRange->All],SmoothHistogram[dat,"Oversmooth","PDF",PlotStyle->Directive[OptionValue[color],Opacity[0.1],Dashed],Filling->Axis,FillingStyle->Directive[OptionValue[color],Opacity[0.1]],PlotRange->{qs,All}],Frame->True,FrameTicks->{Automatic,None},PlotRangePadding->{None,{None,Scaled[0.1]}},FrameStyle->Directive[Black],FrameTicksStyle->Directive[Black,FontFamily->"Times",FontSize->22],FrameLabel->Evaluate[Style[#,Black,FontFamily->"Times",FontSize->26]&/@{lab,"PDF"}],GridLines->{qs,None},GridLinesStyle->Directive[Gray,Dotted],ImageSize->Large]
]


(* ::Input::Initialization:: *)
bnrysrch[lst_,num_]:=If[MemberQ[lst,num]==True,Position[lst,num][[1,1]],N@Mean[Position[lst,#][[1,1]]&/@Nearest[lst,num,2]]]
findCredibilityLevel[data_,levels_List]:=
Module[{srtdata,cumsum,index},
	srtdata=data//Flatten//Sort;
	cumsum=Accumulate[srtdata];
	index=Floor[bnrysrch[cumsum,(1-#)*Last[cumsum]]]&/@levels;
	srtdata[[index]]
]
conpdf[dist_,npix_,siglst_List][lmts_List]:=
Module[{dtnw},
	dtnw=ParallelTable[PDF[dist,{i,j}],
	{i,Range[Sequence@@(lmts[[1]]),Abs[Subtract@@(lmts[[1]])]/npix]},{j,Range[Sequence@@(lmts[[2]]),Abs[Subtract@@(lmts[[2]])]/npix]}];
	findCredibilityLevel[dtnw,Evaluate[sigmaLevel/@siglst]]
]
plmts[dist_,frac_,round1_]:=(N@Round[#,10^-round1])&/@Quantile[dist,{10^-frac,1-10^-frac}]
plmts2[dist_,frac_,round1_,incr_]:=
Module[{pm1=plmts[dist,frac,round1],sep1,sep2},
	sep1=incr*(pm1[[2]]-pm1[[1]]);
	sep2=0.5*(pm1[[2]]+pm1[[1]]);
	{(sep2-sep1/2),(sep2+sep1/2)}
]

(*Thanks to .... https://mathematica.stackexchange.com/questions/20464/how-do-you-draw-credible-regions-intervals-on-a-2d-pdf/127487#127487*)


(* ::Input::Initialization:: *)
Options[distPlot2D]=Join[Options[ContourPlot],Options[SmoothKernelDistribution]]~Join~{colorIndex->1,range->All,style->"Smooth",points->200,siglst->{1,2,3},contourStyle->Directive[White,Dashed],colorFunc->ColorData["Rainbow"]};

distPlot2D[data2D_,lab_,opts:OptionsPattern[]]:=
Module[{dist,rng,conlst,cpl},
dist=SmoothKernelDistribution[data2D,Evaluate[FilterRules[{opts},Options[SmoothKernelDistribution]]]];
rng={MinMax[First/@#],MinMax[Last/@#]}&@data2D;
conlst=conpdf[dist,OptionValue[points],OptionValue[siglst]][rng];
cpl=
Switch[OptionValue[style],
	"SmoothSimple",
	ContourPlot[PDF[dist,{x,y}],Evaluate[{x,Sequence@@rng[[1]]}],Evaluate[{y,Sequence@@rng[[2]]}],Evaluate[FilterRules[{opts},Options[ContourPlot]]]],
	"Smooth",
	ContourPlot[PDF[dist,{x,y}],Evaluate[{x,Sequence@@rng[[1]]}],Evaluate[{y,Sequence@@rng[[2]]}],Contours->conlst,PerformanceGoal->"Quality",
		ContourShading->Reverse@colorsx[OptionValue[colorIndex],Length[OptionValue[siglst]]],GridLines->Automatic,PlotPoints->60,
		AspectRatio->1,PlotRange->All],
	"Density",
	DensityHistogram[data2D,Automatic,"PDF",ColorFunction->Function[{height},OptionValue[colorFunc][height]],PerformanceGoal->"Quality",
		GridLines->Automatic,AspectRatio->1,PlotRange->All],
	"Combo",
	Show[SmoothDensityHistogram[data2D,"Oversmooth","PDF",ColorFunction->OptionValue[colorFunc],PlotRange->All],
		ContourPlot[PDF[dist,{x,y}],Evaluate[{x,Sequence@@rng[[1]]}],Evaluate[{y,Sequence@@rng[[2]]}],Contours->conlst,
			ContourStyle->OptionValue[contourStyle],PerformanceGoal->"Quality",ContourShading->None,PlotPoints->60,PlotRange->All],
		GridLines->Automatic,AspectRatio->1,PlotRange->All]
];
If[MemberQ[{"SmoothSimple"},OptionValue[style]],
cpl,
Show[cpl,FrameStyle->Directive[Black],FrameTicksStyle->Directive[Black,FontFamily->"Times",FontSize->20],FrameLabel->Evaluate[Style[#,Black,FontFamily->"Times",FontSize->26]&/@lab],GridLinesStyle->Directive[Gray,Dotted],ImageSize->Large,PlotRange->Evaluate[If[OptionValue[range]===All,rng,OptionValue[range]]]]
]
]


(* ::Input::Initialization:: *)
Options[Posterior2D]=Join[Options[ContourPlot],Options[SmoothKernelDistribution]]~Join~{colorIndex->1,range->All,xyLabel->"Default",style->"Smooth",bandWidth->Automatic,points->200,siglst->{1,2,3},contourStyle->Directive[White,Dashed],colorFunc->ColorData["Rainbow"]};

Posterior2D::usage="Later"
Posterior2D::nomatch="The supplied 'xylabel' option has something wrong."
Posterior2D[mcres_,parinds_List,opts:OptionsPattern[]]:=
Module[{dat=(#[[parinds]]&/@mcres["ParameterRun"])[[mcres["BurnEnd"];;]],dist,rng,conlst,lab,cpl},
dist=SmoothKernelDistribution[dat,Evaluate[FilterRules[{opts},Options[SmoothKernelDistribution]]]];
rng={MinMax[First/@#],MinMax[Last/@#]}&@dat;
conlst=conpdf[dist,OptionValue[points],OptionValue[siglst]][rng];
If[OptionValue[xyLabel]=!="Default",
		If[!(ListQ[OptionValue[xyLabel]]&&Length[OptionValue[xyLabel]]===Length[parinds]),
			Message[Posterior2D::nomatch];Abort[]
		]
];
lab=If[OptionValue[xyLabel]==="Default",ToString/@mcres["Parameters"][[parinds]],OptionValue[xyLabel]];
cpl=
Switch[OptionValue[style],
	"SmoothSimple",
	ContourPlot[PDF[dist,{x,y}],Evaluate[{x,Sequence@@rng[[1]]}],Evaluate[{y,Sequence@@rng[[2]]}],Evaluate[FilterRules[{opts},Options[ContourPlot]]]],
	"Smooth",
	ContourPlot[PDF[dist,{x,y}],Evaluate[{x,Sequence@@rng[[1]]}],Evaluate[{y,Sequence@@rng[[2]]}],Contours->conlst,PerformanceGoal->"Quality",
		ContourShading->Reverse@colorsx[OptionValue[colorIndex],Length[OptionValue[siglst]]],GridLines->Automatic,PlotPoints->60,
		AspectRatio->1,PlotRange->All],
	"Density",
	DensityHistogram[dat,OptionValue[bandWidth],"PDF",ColorFunction->Function[{height},OptionValue[colorFunc][height]],PerformanceGoal->"Quality",
		GridLines->Automatic,AspectRatio->1,PlotRange->All],
	"Combo",
	Show[SmoothDensityHistogram[dat,OptionValue[bandWidth],"PDF",ColorFunction->OptionValue[colorFunc],PerformanceGoal->"Quality",PlotRange->All],
		ContourPlot[PDF[dist,{x,y}],Evaluate[{x,Sequence@@rng[[1]]}],Evaluate[{y,Sequence@@rng[[2]]}],Contours->conlst,
			ContourStyle->OptionValue[contourStyle],PerformanceGoal->"Quality",ContourShading->None,PlotPoints->60,PlotRange->All],
		GridLines->Automatic,AspectRatio->1,PlotRange->All]
];
If[MemberQ[{"SmoothSimple"},OptionValue[style]],
cpl,
Show[cpl,FrameStyle->Directive[Black],FrameTicksStyle->Directive[Black,FontFamily->"Times",FontSize->20],FrameLabel->Evaluate[Style[#,Black,FontFamily->"Times",FontSize->26]&/@lab],GridLinesStyle->Directive[Gray,Dotted],ImageSize->Large,PlotRange->Evaluate[If[OptionValue[range]===All,rng,OptionValue[range]]]]
]
]

Options[Posterior2DCombo]=Join[Options[Posterior2D],{style1D->"BoxWhisker",PadScale->0.1}];

Posterior2DCombo::usage="Later"
Posterior2DCombo::nomatch="The supplied 'xylabel' option has something wrong."
Posterior2DCombo[mcres_,parinds_List,OptionsPattern[]]:=
Module[{dat=#[[parinds]]&/@mcres["ParameterRun"],dist,rng,conlst,lab,dpl,cpl},
dist=SmoothKernelDistribution[dat];
rng={MinMax[First/@#],MinMax[Last/@#]}&@dat;
conlst=conpdf[dist,OptionValue[points],OptionValue[siglst]][rng];
If[OptionValue[xyLabel]=!="Default",
		If[!(ListQ[OptionValue[xyLabel]]&&Length[OptionValue[xyLabel]]===Length[parinds]),
			Message[Posterior2D::nomatch];Abort[]
		]
];
lab=If[OptionValue[xyLabel]==="Default",ToString/@mcres["Parameters"][[parinds]],OptionValue[xyLabel]];
dpl=DensityHistogram[dat,ColorFunction->(Opacity[0]&),Method->{"DistributionAxes"->OptionValue[style1D]},PlotRange->rng];
cpl=
Switch[OptionValue[style],
	"Smooth",
	ContourPlot[PDF[dist,{x,y}],Evaluate[{x,Sequence@@rng[[1]]}],Evaluate[{y,Sequence@@rng[[2]]}],Contours->conlst,PerformanceGoal->"Quality",
		ContourShading->Reverse@colorsx[OptionValue[colorIndex],Length[OptionValue[siglst]]],GridLines->Automatic,PlotPoints->60,
		AspectRatio->1,PlotRange->All],
	"Density",
	DensityHistogram[dat,Automatic,"PDF",ColorFunction->Function[{height},OptionValue[colorFunc][height]],PerformanceGoal->"Quality",
		GridLines->Automatic,AspectRatio->1,PlotRange->All],
	"Combo",
	Show[SmoothDensityHistogram[dat,"Oversmooth","PDF",ColorFunction->OptionValue[colorFunc],PlotRange->All],
		ContourPlot[PDF[dist,{x,y}],Evaluate[{x,Sequence@@rng[[1]]}],Evaluate[{y,Sequence@@rng[[2]]}],Contours->conlst,
			ContourStyle->Directive[OptionValue[contourStyle],Dashed],PerformanceGoal->"Quality",ContourShading->None,PlotPoints->60,PlotRange->All],
		GridLines->Automatic,AspectRatio->1,PlotRange->rng]
];
Show[dpl,cpl,FrameStyle->Directive[Black],FrameTicksStyle->Directive[Black,FontFamily->"Times",FontSize->20],FrameLabel->Evaluate[Style[#,Black,FontFamily->"Times",FontSize->26]&/@lab],GridLinesStyle->Directive[Gray,Dotted],ImageSize->Large,PlotRange->rng,PlotRangePadding->{{Scaled[0.02],Scaled[0.02]},{Scaled[0.02],Scaled[0.02]}}]
]


(* ::Input::Initialization:: *)
Options[triPlotPosterior]=Join[Options[PlotFisher2D],{labelSize->16,frameSize->180,padlabelx->50,padlabely->62,padnolabelx->25,padnolabely->25,padnonumbers->8}];
triPlotPosterior::usage="triPlotFisher[fitobj] creates a table of 1 and 2 dimensional PDF plots of the priors for the supplied fitObject - 'fitobj'. \nFor now, only nuisance parameters can be used in this way."
triPlotPosterior::nonuis="The supplied fitObject has no nuisance parameters in it."
triPlotPosterior[mcres_,opts:OptionsPattern[]]:=
Module[{res=mcres["BestFitParameters"],covm,pars,vals,nada,parlabelsx,impad,imsz,frl},
pars=ToString/@(mcres["Parameters"]);
vals=Values[res];
covm=covMatGen[Values[mcres["ParameterErrors"]],mcres["CorrelationMatrix"][[1]]];nada=Text[Style[" ",FontSize->OptionValue[labelSize]]];parlabelsx=(Text[Style[#1,FontFamily->"Times New Roman",Black,FontSize->OptionValue[labelSize]]]&)/@pars;impad[i_,j_]:=impadDef[i,j,OptionValue[padlabelx],OptionValue[padnolabelx],OptionValue[padlabely],OptionValue[padnolabely],OptionValue[padnonumbers],Length[pars]];imsz[i_,j_]:=imszDef[i,j,OptionValue[frameSize],OptionValue[padlabelx],OptionValue[padnolabelx],OptionValue[padlabely],OptionValue[padnolabely],OptionValue[padnonumbers],Length[pars]];frl[i_,j_]:=frlDef[i,j,nada,Length[pars],parlabelsx];Grid[ReplacePart[ConstantArray[Null,{Length[pars],Length[pars]}],{{i_,i_}:>Show[triPlotPartMVG[vals,covm,i,i,OptionValue[style],Evaluate[FilterRules[{opts},Options[triPlotPartMVG]]]],FrameLabel->frl[i,i],ImagePadding->impad[i,i],ImageSize->imsz[i,i]],{i_,j_}/;i>j:>Show[triPlotPartMVG[vals,covm,i,j,OptionValue[style],Evaluate[FilterRules[{opts},Options[triPlotPartMVG]]]],FrameLabel->frl[i,j],ImagePadding->impad[i,j],ImageSize->imsz[i,j]]}],Spacings->{0,0}]]


(* ::Input::Initialization:: *)
Options[savePlots1D]=Join[Options[Posterior1D],{fileType->"png",imageRes->200}];

savePlots1D::usage="Later"
savePlots1D::nomatch="The supplied 'xlabel' option has something wrong."
savePlots1D[mcres_,runname_String,plotname_String,opts:OptionsPattern[]]:=
Module[{dirname=FileNameJoin[{NotebookDirectory[],"OptExMCRuns","OptExMC_"<>runname}],namlst},
	If[!DirectoryQ[dirname],
		If[!DirectoryQ[FileNameJoin[{NotebookDirectory[],"OptExMCRuns"}]],
			CreateDirectory[FileNameJoin[{NotebookDirectory[],"OptExMCRuns"}]]
		];
		CreateDirectory[dirname]
	];
	If[!DirectoryQ[FileNameJoin[{dirname,"Plots"}]],
		CreateDirectory[FileNameJoin[{dirname,"Plots"}]]
	];
	If[OptionValue[xLabel]=!="Default",
		If[!(ListQ[OptionValue[xLabel]]&&Length[OptionValue[xLabel]]===Length[mcres["Parameters"]]),
			Message[savePlots1D::nomatch];Abort[]
		]
	];
	namlst=If[OptionValue[xLabel]==="Default",ToString/@mcres["Parameters"],OptionValue[xLabel]];
	Map[Export[FileNameJoin[{dirname,"Plots","Plot1D_"<>runname<>"_"<>plotname<>"_"<>ToString[#]<>"."<>OptionValue[fileType]}],
		Posterior1D[mcres,#,xLabel->namlst[[#]],Evaluate[FilterRules[{opts},Except[xLabel,Options[Posterior1D]]]]],
		ImageResolution->OptionValue[imageRes]]&,
		Range[Length[mcres["Parameters"]]]];
]


(* ::Input::Initialization:: *)
Options[savePlots2D]=Join[Options[Posterior2D],{fileType->"png",imageRes->200}];

savePlots2D::usage="Later"
savePlots2D::nomatch="The supplied 'xylabel' option has something wrong."
savePlots2D[mcres_,runname_,plotname_,opts:OptionsPattern[]]:=
Module[{dirname=FileNameJoin[{NotebookDirectory[],"OptExMCRuns","OptExMC_"<>runname}],combos,namlst},
	If[!DirectoryQ[dirname],
		If[!DirectoryQ[FileNameJoin[{NotebookDirectory[],"OptExMCRuns"}]],
			CreateDirectory[FileNameJoin[{NotebookDirectory[],"OptExMCRuns"}]]
		];
		CreateDirectory[dirname]
	];
	If[!DirectoryQ[FileNameJoin[{dirname,"Plots"}]],
		CreateDirectory[FileNameJoin[{dirname,"Plots"}]]
	];
	If[OptionValue[xyLabel]=!="Default",
		If[ListQ[OptionValue[xyLabel]]&&Length[OptionValue[xyLabel]]===Length[mcres["Parameters"]],
			Message[savePlots2D::nomatch];Abort[]
		]
	];
	combos=Subsets[Range[Length[mcres["Parameters"]]],{2}];
	namlst=If[OptionValue[xyLabel]==="Default",ToString/@mcres["Parameters"],OptionValue[xyLabel]];
	Do[Export[FileNameJoin[{dirname,"Plots","Plot2D_"<>runname<>"_"<>plotname<>"_"<>ToString[combos[[i,1]]]<>"vs"
							<>ToString[combos[[i,2]]]<>"."<>OptionValue[fileType]}],
			Posterior2D[mcres,combos[[i]],xyLabel->Evaluate[namlst[[combos[[i]]]]],Evaluate[FilterRules[{opts},Except[xyLabel,Options[Posterior2D]]]]],
			ImageResolution->OptionValue[imageRes]],
		{i,Length[combos]}];
]


(* ::Input::Initialization:: *)
End[]


(* ::Input::Initialization:: *)
EndPackage[];
(*SetAttributes[{addData,addParam,apply,assoObject,assoObjectQ,asymmErrSimple,batchFitObjectQ,batchFitParam,BayesFastFit,BayesMathFit,BayesMathFit2,chiSqBayes,chiSqForm,chiSqFormFit,chiSqFormFitP,chiSqFormP,chiSqMinimForm,chiSqMinObject,chiSqMinObjectQ,chiSqTab,CLObjectQ,CLPlot1D,CLPlot2D,CLProbObject,CLResult1D,CLScanFC1D,CLScanProb1D,CLScanProb2D,colorPalette,colorsx,ConfLevel,constraintForm,cookCutoff,cookDistance,correlationCreate,correlationForm,covMatForm,covMatGen,dataForm,dataObject,dataObjectQ,deltaChiSqVal,dofSimple,Emerald,endPoints,errorDisplay,errorDisplay1,errorDisplay2,errorDisplayList,errorFormat,errorInfo,errorMat,errorMatForm,errorProp,FitFromBatch,fitObject,fitObjectQ,freeParamForm,HDReg,HesseResult1D,hessianMat,Iris,kFoldXValidation,listObject,loadRun,matrixSymmetrize,MCMCFast,MCMCMath,MCMCMath2,MCMCResult,MCMCResultQ,modelLogLike,modelSelect,MSEfit,MSEpart,NHessian,nuisanceForm,obAr,objectType,OptExHelp,paramList,paramObject,paramObjectQ,partFit,PlotFisher2D,PlotPrior2D,pMC1D,populateData,Posterior1D,Posterior2D,Posterior2DCombo,priorBayes,priorLogDensity,pSimulData,pulls,pValue,pValueMC,rangeForm,removeData,removeParam,resultForm,resultTable,savePlots1D,savePlots2D,saveRun,scanObject,showPalette,sigDigit,sigmaLevel,TangerineTango,texTable,triPlotFisher,triPlotPartMVG,triPlotPartUni,triPlotPrior,vecForm,vecFormP,$GuideDirectory,$OptExDirectory,$OptExVersion},{Protected,ReadProtected,Locked}]*)



